{"version":3,"file":"index.cjs","sources":["../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/scopes/components/location-manager/location-manager.ts","../src/utils/removeUndefined.ts","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/utils.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/copyTextToClipboard.ts","../src/scopes/utilities/uncategorized/downloadFile.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareMessage.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_$launchParams, $launchParams] = createSignalsTuple<PackageLaunchParams>({\n  tgWebAppPlatform: 'unknown',\n  tgWebAppVersion: '0.0',\n});\n\nexport const version = createComputed(() => $launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _$launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _$launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);\n\nexport const [\n  UnknownThemeParamsKeyError,\n  isUnknownThemeParamsKeyError,\n] = errorClass<[key: string]>('UnknownThemeParamsKeyError', key => {\n  return [`Unknown theme params key passed: ${key}`];\n});","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport { array, parse, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      const response = {\n        // Fulfill the response with probably missing keys.\n        ...keys.reduce<Record<string, string>>((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {}),\n        ...parse(record(string(), string()), data),\n      };\n\n      return typeof keyOrKeys === 'string' ? response[keyOrKeys] : response;\n    })\n    : AbortablePromise.resolve(Array.isArray(keyOrKeys) ? {} : '');\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport { batch } from '@telegram-apps/signals';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  (_options?: RequestOptionsNoCapture): AbortablePromise<ThemeParams> => {\n    return AbortablePromise.resolve(\n      (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {},\n    );\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapBasic('mountSync', () => {\n  if (!_isMounted()) {\n    const tp = (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {};\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    batch(() => {\n      _state.set(tp);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport type { RGB } from '@telegram-apps/types';\nimport { isRGB } from '@telegram-apps/transformers';\n\nimport { state as themeParamsState } from '@/scopes/components/theme-params/signals.js';\nimport { createComputed } from '@/signals-registry.js';\n\nimport type { AnyColor } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nexport function rgbComputedBasedOn(signal: Computed<AnyColor>): Computed<RGB | undefined> {\n  return createComputed<RGB | undefined>(() => rgbBasedOn(signal()));\n}\n\nexport function rgbBasedOn(color: AnyColor): RGB | undefined {\n  return isRGB(color) ? color : themeParamsState()[color];\n}","import { isRGB } from '@telegram-apps/transformers';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  state as themeParamsState,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport { rgbComputedBasedOn } from './utils.js';\n\nimport type { AnyColor, State } from './types.js';\n\n/**\n * The Mini App background color.\n *\n * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n *\n * Note that using a theme parameters key, background color becomes bound to the current\n * theme parameters, making it automatically being updated whenever theme parameters change.\n * In order to remove this bind, use an explicit RGB color.\n */\nexport const [_backgroundColor, backgroundColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbComputedBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] = createSignalsTuple<AnyColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    // Falling back to secondary_bg_color following the logic from the Telegram SDK.\n    : themeParamsState()[color] || themeSecondaryBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbComputedBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { type Computed, type SubscribeListenerFn, batch } from '@telegram-apps/signals';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\n\nimport { version, postEvent } from '@/globals.js';\nimport {\n  mount as mountThemeParams,\n  mountSync as mountThemeParamsSync,\n} from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { AnyColor, GetCssVarNameFn, State } from './types.js';\nimport { rgbBasedOn } from './utils.js';\nimport { themeParamsState } from '@/scopes/components/theme-params/exports.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst onThemeParamsChanged: SubscribeListenerFn<ThemeParams> = themeParams => {\n  ([\n    [_headerColor, SET_HEADER_COLOR_METHOD],\n    [_backgroundColor, SET_BG_COLOR_METHOD],\n    [_bottomBarColor, SET_BOTTOM_BAR_COLOR_METHOD],\n  ] as const).forEach(([signal, method]) => {\n    const color = signal();\n    if (!isRGB(color) && (\n      // Header color setter uses additional checks. We don't apply changes if the current\n      // value is a known color key because it updates automatically by itself.\n      method !== SET_HEADER_COLOR_METHOD\n      || (color !== 'bg_color' && color !== 'secondary_bg_color')\n    )) {\n      const rgb = themeParams[color];\n      rgb && postEvent(method, { color: rgb });\n    }\n  });\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapSupported('mountSync', () => {\n  if (!_isMounted()) {\n    mountThemeParamsSync();\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n\n    batch(() => {\n      _isActive.set(s ? s.isActive : true);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: AnyColor): void => {\n    if (color === _backgroundColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BG_COLOR_METHOD, { color: rgb });\n    _backgroundColor.set(color);\n    saveState();\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('#ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: AnyColor) => {\n    if (color === _bottomBarColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color: rgb });\n    _bottomBarColor.set(color);\n    saveState();\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: AnyColor): void => {\n    if (color === _headerColor()) {\n      return;\n    }\n    if (color === 'bg_color' || color === 'secondary_bg_color') {\n      postEvent(SET_HEADER_COLOR_METHOD, { color_key: color });\n    } else {\n      const rgb = rgbBasedOn(color);\n      if (!rgb) {\n        throw new UnknownThemeParamsKeyError(color);\n      }\n      postEvent(SET_HEADER_COLOR_METHOD, { color: rgb });\n    }\n    _headerColor.set(color);\n    saveState();\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  themeParamsState.unsub(onThemeParamsChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { ShowOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [fn, tPromise, tShowError] = defineNonConcurrentFn(\n  (options: ShowOptions): AbortablePromise<string | null> => {\n    return request(OPEN_METHOD, 'popup_closed', {\n      ...options,\n      params: prepareParams(options),\n    }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n  },\n  'A popup is already opened',\n);\n\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `show` instead.\n */\nexport const open = wrapSupported('open', fn);\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showPromise` instead.\n */\nconst openPromise = tPromise[1];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `isShown` instead.\n */\nconst isOpened = tPromise[2];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showError` instead.\n */\nconst openError = tShowError[1];\n\nexport { openPromise, isOpened, openError };\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const show = wrapSupported('show', fn);\nexport const [, showPromise, isShown] = tPromise;\nexport const [, showError] = tShowError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = $launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\nconst fnOptions = {\n  isSupported: 'web_app_request_phone',\n} as const;\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContactCompleteData> {\n  const raw = parse(string(), await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  }));\n  return {\n    raw,\n    parsed: parse(\n      pipe(\n        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n        union([string(), instance(URLSearchParams)]),\n        transformQueryUsing(\n          looseObject({\n            contact: pipe(\n              string(),\n              jsonParse(),\n              looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              }),\n            ),\n            auth_date: pipe(\n              string(),\n              transform(input => new Date(Number(input) * 1000)),\n              date(),\n            ),\n            hash: string(),\n          }),\n        ),\n      ),\n      raw,\n    ),\n  };\n}\n\nconst [fn, tPromise, tError] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContactCompleteData> => {\n    return new AbortablePromise<RequestedContactCompleteData>(\n      async (res, _, context) => {\n        // First of all, let's try to get the requested contact. Probably, we already requested it\n        // before.\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Then, request access to the user's phone.\n        const status = await requestPhoneAccess(context);\n        if (status !== 'sent') {\n          throw new AccessDeniedError('User denied access');\n        }\n\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isAborted()) {\n          try {\n            return res(await getRequestedContact(context));\n          } catch (e) {\n            if (e instanceof ValiError) {\n              throw e;\n            }\n          }\n\n          // Sleep for some time.\n          await sleep(sleepTime);\n\n          // Increase the sleep time not to kill the backend service.\n          sleepTime += 50;\n        }\n      },\n      options,\n    );\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n *\n * This function returns an object, containing both raw and parsed representations of the response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContactComplete.isAvailable()) {\n *   const completeData = await requestContactComplete();\n * }\n */\nexport const requestContactComplete = wrapSafe('requestContactComplete', fn, fnOptions);\n\n/**\n * Works the same way as the `requestContactComplete` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactComplete\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe(\n  'requestContact',\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return requestContactComplete(options).then(r => r.parsed);\n  },\n  fnOptions,\n);\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_data_send';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent(METHOD_NAME, { data });\n  },\n  { isSupported: METHOD_NAME },\n);\n","import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { $launchParams, postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n  {\n    isSupported() {\n      return $launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    }\n  }\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["createSignal","initialValue","options","signal","createComputed","fn","computed","createSignalsTuple","s","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_$launchParams","$launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","ShareMessageError","isShareMessageError","UnknownThemeParamsKeyError","isUnknownThemeParamsKeyError","key","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","k","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","on","offClick","off","show","unmount","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","e","defineMountFn","onMounted","rest","data","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","p","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","r","createWrapMounted","createWrapBasic","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","wrapBasic","disableConfirmation","setClosingConfirmation","enableConfirmation","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","response","acc","parse","record","string","getItem","getKeys","array","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","d","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","CHECK_LOCATION_METHOD","OPEN_SETTINGS_METHOD","isAccessGranted","isAccessRequested","reqLocationFn","tReqLocationPromise","tReqLocationError","requestLocation","requestLocationPromise","isRequestingLocation","requestLocationError","removeUndefined","result","v","isColorDark","color","rgb","toRGB","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","_options","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","mountSync","tp","rgbComputedBasedOn","rgbBasedOn","isRGB","themeParamsState","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeSecondaryBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","onThemeParamsChanged","themeParams","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","mountThemeParamsSync","ready","prepareParams","title","buttons","b","id","OPEN_METHOD","tPromise","tShowError","buttonId","showPromise","isShown","showError","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","w","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","fnOptions","getRequestedContact","pipe","union","instance","transformQueryUsing","looseObject","jsonParse","number","optional","transform","input","date","res","_","ValiError","sleepTime","requestContactComplete","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","fallback","textArea","copyTextToClipboard","clipboard","downloadFile","fileName","getCurrentTime","integer","readTextFromClipboard","reqId","captureSameReq","sendData","size","shareMessage","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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"}