import { setDebug as cn, retrieveLaunchParams as wo, createPostEvent as un, invokeCustomMethod as ln, request as pn, postEvent as dn, supports as oe, isTMA as Jt, on as d, off as E, retrieveRawInitData as mn, captureSameReq as _n } from "@telegram-apps/bridge";
import { AbortablePromise as Wl, CancelledError as Ql, InvalidLaunchParamsError as Kl, InvokeCustomMethodError as Yl, LaunchParamsRetrieveError as Xl, ManualPromise as Zl, MethodParameterUnsupportedError as Jl, MethodUnsupportedError as ep, TimeoutError as tp, UnknownEnvError as op, createPostEvent as sp, emitEvent as np, isCancelledError as rp, isInvalidLaunchParamsError as ap, isInvokeCustomMethodError as ip, isLaunchParamsRetrieveError as cp, isMethodMethodParameterUnsupportedError as up, isMethodUnsupportedError as lp, isTMA as pp, isTimeoutError as dp, isUnknownEnvError as mp, mockTelegramEnv as _p, off as fp, on as hp, postMessage as bp, postMessageImplementation as gp, retrieveLaunchParams as Ep, retrieveRawInitData as Sp, retrieveRawLaunchParams as wp, supports as Cp, targetOrigin as $p } from "@telegram-apps/bridge";
import { createLogger as fn, getStorageValue as S, setStorageValue as M, snakeToKebab as hn, createCbCollector as tt, camelToKebab as Co } from "@telegram-apps/toolkit";
import { isPageReload as w } from "@telegram-apps/navigation";
import { computed as bn, signal as gn, batch as se } from "@telegram-apps/signals";
import { errorClass as A } from "error-kid";
import { AbortablePromise as f, isCancelledError as En, ManualPromise as Sn } from "better-promises";
import { parse as ne, array as wn, string as $, record as Cn, ValiError as eo, pipe as fe, union as $n, instance as Mn, looseObject as to, number as $o, optional as An, transform as Mo, date as Ao, integer as vn } from "valibot";
import { toRGB as yn, isRGB as we, transformQueryUsing as Bn, jsonParse as Pn } from "@telegram-apps/transformers";
import { isRGB as Ap, isRGBShort as vp, parseInitDataQuery as yp, parseLaunchParamsQuery as Bp, serializeInitDataQuery as Pp, serializeLaunchParamsQuery as Tp, serializeToQuery as kp, toRGB as Op, transformQueryUsing as Ip } from "@telegram-apps/transformers";
// @__NO_SIDE_EFFECTS__
function G(e, t) {
  return gn(e, t);
}
// @__NO_SIDE_EFFECTS__
function c(e, t) {
  return bn(e, t);
}
// @__NO_SIDE_EFFECTS__
function u(e, t) {
  const o = /* @__PURE__ */ G(e, t);
  return [o, /* @__PURE__ */ c(o)];
}
let vo = !1;
const [Qe, Bu] = fn("SDK", {
  bgColor: "forestgreen",
  textColor: "white",
  shouldLog() {
    return vo;
  }
});
function Pu(e) {
  vo = e, cn(e);
}
const je = /* @__PURE__ */ G(0), yo = /* @__PURE__ */ G(dn), [oo, le] = /* @__PURE__ */ u({
  tgWebAppPlatform: "unknown",
  tgWebAppVersion: "0.0"
}), k = /* @__PURE__ */ c(() => le().tgWebAppVersion);
function Tn(e) {
  e || (e = {});
  const { postEvent: t } = e, o = e.launchParams || wo();
  oo.set(o), yo.set(
    typeof t == "function" ? t : un(o.tgWebAppVersion)
  ), Qe(!1, "The package was configured. Launch params:", oo());
}
function Bo() {
  return je.set(je() + 1), je().toString();
}
function z(e, t, o) {
  return ln(e, t, Bo(), {
    ...o || {},
    postEvent: i
  });
}
const p = (e, t, o) => (o || (o = {}), o.postEvent || (o.postEvent = i), pn(e, t, o)), i = (e, t) => yo()(e, t);
function v(e) {
  return /* @__PURE__ */ c(() => oe(e, k()));
}
function H(e) {
  return [e];
}
const [
  ot,
  Tu
] = A("CSSVarsBoundError", "CSS variables are already bound"), [
  Po,
  ku
] = A("NotAvailableError", H), [
  Ou,
  Iu
] = A("InvalidEnvError", H), [
  Z,
  qu
] = A("FunctionNotAvailableError", H), [
  y,
  Vu
] = A(
  "InvalidArgumentsError",
  (e, t) => [e, { cause: t }]
), [
  kn,
  xu
] = A("ConcurrentCallError", H), [
  On,
  Nu
] = A(
  "SetEmojiStatusError",
  (e) => [`Failed to set emoji status: ${e}`]
), [
  To,
  Du
] = A("AccessDeniedError", H), [
  In,
  Hu
] = A("FullscreenFailedError", H), [
  qn,
  Lu
] = A("ShareMessageError", H), [
  st,
  Ru
] = A("UnknownThemeParamsKeyError", (e) => [`Unknown theme params key passed: ${e}`]);
function so() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function l(e, t, o) {
  o || (o = {});
  const {
    isSupported: s,
    isMounted: n,
    isMounting: r,
    component: a,
    supports: m
  } = o || {}, Y = `${a ? `${a}.` : ""}${e}()`, P = s ? Array.isArray(s) || typeof s == "object" && "any" in s ? s : [s] : void 0;
  function X(g) {
    if (m) {
      const _ = m[g];
      return oe(_[0], _[1], k());
    }
    return !0;
  }
  function T() {
    if (!P)
      return;
    function g(F) {
      return typeof F == "function" ? F() : oe(F, k()) ? void 0 : `it is unsupported in Mini Apps version ${k()}`;
    }
    const _ = Array.isArray(P) ? P : P.any, V = _.map(g).filter(Boolean);
    return Array.isArray(P) ? V[0] : V.length === _.length ? V[V.length - 1] : void 0;
  }
  function rn(...g) {
    for (const _ in m)
      if (m[_][2](...g) && !X(_))
        return `option ${_} is not supported in Mini Apps version ${k()}`;
  }
  let _e;
  if (m) {
    _e = {};
    for (const g in m)
      _e[g] = /* @__PURE__ */ c(() => X(g));
  }
  const Kt = /* @__PURE__ */ c(() => !T()), Yt = /* @__PURE__ */ c(() => k() !== "0.0"), Xt = /* @__PURE__ */ c(() => !n || n()), Zt = /* @__PURE__ */ c(
    () => Jt() && !so() && Yt() && Kt() && Xt()
  );
  return Object.assign(
    (...g) => {
      const _ = `Unable to call the ${Y} ${a ? "method" : "function"}:`;
      if (so() || !Jt())
        throw new Z(`${_} it can't be called outside Mini Apps`);
      if (!Yt())
        throw new Z(`${_} the SDK was not initialized. Use the SDK init() function`);
      const V = T();
      if (V)
        throw new Z(`${_} ${V}`);
      const F = rn(...g);
      if (F)
        throw new Z(`${_} ${F}`);
      if (!Xt()) {
        const an = r && r() ? "mounting. Wait for the mount completion" : `unmounted. Use the ${a}.mount() method`;
        throw new Z(`${_} the component is ${an}`);
      }
      return t(...g);
    },
    t,
    {
      isAvailable: Zt,
      ifAvailable(...g) {
        return Zt() ? [!0, t(...g)] : [!1];
      }
    },
    P ? { isSupported: Kt } : {},
    _e ? { supports: _e } : {}
  );
}
function Ce(e, t) {
  return t || (t = {}), (o, s, n, r) => /* @__PURE__ */ l(o, s, {
    ...t,
    isSupported: n || t.isSupported,
    supports: r,
    component: e
  });
}
function O(e, t, o) {
  return Ce(e, { isSupported: o, isMounted: t });
}
function C(e, t) {
  return Ce(e, { isSupported: t });
}
const $e = "web_app_setup_back_button", ko = "back_button_pressed", Me = "backButton", [no, Vn] = /* @__PURE__ */ u(!1), [he, xn] = /* @__PURE__ */ u(!1), Nn = v($e), Oo = O(Me, he, $e), nt = C(Me, $e), Dn = Oo("hide", () => {
  rt(!1);
}), Hn = nt("mount", () => {
  he() || (rt(w() && S(Me) || !1), he.set(!0));
});
function rt(e) {
  e !== no() && (i($e, { is_visible: e }), M(Me, e), no.set(e));
}
const Ln = nt(
  "onClick",
  (e) => d(ko, e)
), Rn = nt(
  "offClick",
  (e) => {
    E(ko, e);
  }
), jn = Oo("show", () => {
  rt(!0);
});
function Fn() {
  he.set(!1);
}
const ju = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Dn,
  isMounted: xn,
  isSupported: Nn,
  isVisible: Vn,
  mount: Hn,
  offClick: Rn,
  onClick: Ln,
  show: jn,
  unmount: Fn
}, Symbol.toStringTag, { value: "Module" }));
function b(e, t, o) {
  o || (o = {});
  const {
    promise: s,
    error: n
  } = o, [r, a] = s ? [s, /* @__PURE__ */ c(s)] : /* @__PURE__ */ u(), [m, Y] = n ? [n, /* @__PURE__ */ c(n)] : /* @__PURE__ */ u();
  return [
    Object.assign((...P) => {
      if (r()) {
        const T = new kn(t);
        return m.set(T), f.reject(T);
      }
      se(() => {
        r.set(e(...P)), m.set(void 0);
      });
      let X;
      return r().catch((T) => {
        throw X = T, T;
      }).finally(() => {
        se(() => {
          r.set(void 0), m.set(X);
        });
      });
    }, e),
    [r, a, /* @__PURE__ */ c(() => !!r())],
    [m, Y]
  ];
}
// @__NO_SIDE_EFFECTS__
function pe(e, t, o) {
  const [s, ...n] = b(t, `The ${e} component is already mounting`), [r, a] = /* @__PURE__ */ u(!1);
  return [
    (...m) => r() ? f.resolve() : s(...m).then((Y) => {
      se(() => {
        r.set(!0), o(Y);
      });
    }),
    ...n,
    [r, a]
  ];
}
const [at, Un] = /* @__PURE__ */ u({
  available: !1,
  type: "",
  accessGranted: !1,
  accessRequested: !1,
  deviceId: "",
  tokenSaved: !1
}), Gn = /* @__PURE__ */ c(() => at().available), ro = "web_app_biometry_get_info", zn = /* @__PURE__ */ l(
  "requestBiometry",
  (e) => p(ro, "biometry_info_received", e),
  { isSupported: ro }
);
function Io(e) {
  if (!En(e))
    throw e;
}
function W(e) {
  const t = e();
  t && t.catch(Io).cancel();
}
const re = "biometry", Ae = "web_app_biometry_request_auth", it = "biometry_info_received", qo = (e) => {
  ve(ct(e));
};
function Vo() {
  throw new Po("Biometry is not available");
}
function ct(e) {
  let t = !1, o = !1, s = "", n = !1, r = "", a = !1;
  return e.available && (t = !0, o = e.token_saved, s = e.device_id, n = e.access_requested, r = e.type, a = e.access_granted), { available: t, tokenSaved: o, deviceId: s, type: r, accessGranted: a, accessRequested: n };
}
const Wn = v(Ae), [
  Qn,
  Kn,
  Yn,
  xo
] = /* @__PURE__ */ pe(
  re,
  (e) => {
    const t = w() && S(re);
    return t ? f.resolve(t) : zn({ abortSignal: e }).then(ct);
  },
  (e) => {
    d(it, qo), ve(e);
  }
), No = C(re, Ae), ut = O(re, xo[0], Ae), Xn = No("mount", Qn), [, Do, Zn] = Kn, [, Jn] = Yn, [er, tr] = xo, [
  or,
  sr,
  nr
] = b(
  (e) => f.fn(async (t) => {
    const o = at();
    o.available || Vo();
    const s = await p(Ae, "biometry_auth_requested", {
      ...e,
      ...t,
      params: { reason: ((e || {}).reason || "").trim() }
    }), { token: n } = s;
    return typeof n == "string" && ve({ ...o, token: n }), s;
  }, e),
  "Biometry authentication is already in progress"
), rr = ut("authenticate", or), [, Ho, ar] = sr, [, ir] = nr, cr = No("openSettings", () => {
  i("web_app_biometry_open_settings");
}), [
  ur,
  lr,
  pr
] = b(
  (e) => f.fn(async (t) => {
    const o = await p("web_app_biometry_request_access", it, {
      ...e,
      ...t,
      params: { reason: (e || {}).reason || "" }
    }).then(ct);
    return o.available || Vo(), ve(o), o.accessGranted;
  }, e),
  "Biometry access request is already in progress"
), dr = ut("requestAccess", ur), [, Lo, mr] = lr, [, _r] = pr;
function ve(e) {
  at.set(e), M(re, e);
}
function fr() {
  [Ho, Lo, Do].forEach(W), E(it, qo), er.set(!1);
}
const hr = ut(
  "updateToken",
  (e) => (e || (e = {}), p("web_app_biometry_update_token", "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t) => t.status))
), Fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authError: ir,
  authPromise: Ho,
  authenticate: rr,
  isAuthenticating: ar,
  isAvailable: Gn,
  isMounted: tr,
  isMounting: Zn,
  isRequestingAccess: mr,
  isSupported: Wn,
  mount: Xn,
  mountError: Jn,
  mountPromise: Do,
  openSettings: cr,
  requestAccess: dr,
  requestAccessError: _r,
  requestAccessPromise: Lo,
  state: Un,
  unmount: fr,
  updateToken: hr
}, Symbol.toStringTag, { value: "Module" }));
function ye(e, t) {
  return Ce(e, { isMounted: t });
}
const I = Ce, Be = "closingBehavior", [ao, br] = /* @__PURE__ */ u(!1), [Ke, Ro] = /* @__PURE__ */ u(!1), jo = ye(Be, Ro), gr = I(Be), Er = jo("disableConfirmation", () => {
  lt(!1);
}), Sr = jo("enableConfirmation", () => {
  lt(!0);
}), wr = gr("mount", () => {
  Ke() || (lt(
    w() && S(Be) || !1
  ), Ke.set(!0));
});
function lt(e) {
  e !== ao() && (i("web_app_setup_closing_behavior", { need_confirmation: e }), M(Be, e), ao.set(e));
}
function Cr() {
  Ke.set(!1);
}
const Uu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: Er,
  enableConfirmation: Sr,
  isConfirmationEnabled: br,
  isMounted: Ro,
  mount: wr,
  unmount: Cr
}, Symbol.toStringTag, { value: "Module" })), Fo = "web_app_invoke_custom_method", de = C("cloudStorage", Fo), $r = v(Fo), Uo = de("deleteItem", (e, t) => {
  const o = Array.isArray(e) ? e : [e];
  return o.length ? z("deleteStorageValues", { keys: o }, t).then() : f.resolve();
});
function Mr(e, t) {
  const o = Array.isArray(e) ? e : [e];
  return o.length ? z("getStorageValues", { keys: o }, t).then((s) => {
    const n = {
      // Fulfill the response with probably missing keys.
      ...o.reduce((r, a) => (r[a] = "", r), {}),
      ...ne(Cn($(), $()), s)
    };
    return typeof e == "string" ? n[e] : n;
  }) : f.resolve(Array.isArray(e) ? {} : "");
}
const Ar = de("getItem", Mr), Go = de("getKeys", (e) => z("getStorageKeys", {}, e).then(
  (t) => ne(wn($()), t)
)), vr = de("setItem", (e, t, o) => z("saveStorageValue", {
  key: e,
  value: t
}, o).then()), yr = de("clear", (e) => Go(e).then(Uo)), Gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clear: yr,
  deleteItem: Uo,
  getItem: Ar,
  getKeys: Go,
  isSupported: $r,
  setItem: vr
}, Symbol.toStringTag, { value: "Module" })), me = "web_app_trigger_haptic_feedback", pt = C("hapticFeedback", me), Br = v(me), Pr = pt(
  "impactOccurred",
  (e) => {
    i(me, {
      type: "impact",
      impact_style: e
    });
  }
), Tr = pt(
  "notificationOccurred",
  (e) => {
    i(me, {
      type: "notification",
      notification_type: e
    });
  }
), kr = pt(
  "selectionChanged",
  () => {
    i(me, { type: "selection_change" });
  }
), zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: Pr,
  isSupported: Br,
  notificationOccurred: Tr,
  selectionChanged: kr
}, Symbol.toStringTag, { value: "Module" })), [zo, Or] = /* @__PURE__ */ u(void 0);
function B(e) {
  return /* @__PURE__ */ c(() => {
    const t = zo();
    return t ? t[e] : void 0;
  });
}
const Wo = B("auth_date"), Qo = B("can_send_after"), Ir = /* @__PURE__ */ c(() => {
  const e = Wo(), t = Qo();
  return t && e ? new Date(e.getTime() + t * 1e3) : void 0;
}), qr = B("chat"), Vr = B("chat_type"), xr = B("chat_instance"), Nr = B("hash"), Dr = B("query_id"), [Hr, Lr] = /* @__PURE__ */ u(), Rr = B("receiver");
function jr() {
  const e = wo();
  zo.set(e.tgWebAppData), Hr.set(mn());
}
const Fr = B("start_param"), Ur = B("user"), Wu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: Wo,
  canSendAfter: Qo,
  canSendAfterDate: Ir,
  chat: qr,
  chatInstance: xr,
  chatType: Vr,
  hash: Nr,
  queryId: Dr,
  raw: Lr,
  receiver: Rr,
  restore: jr,
  startParam: Fr,
  state: Or,
  user: Ur
}, Symbol.toStringTag, { value: "Module" })), dt = "web_app_open_invoice", Gr = C("invoice", dt), zr = v(dt);
function Wr(e, t, o) {
  let s;
  if (t === "url") {
    const { hostname: n, pathname: r } = new URL(e, window.location.href);
    if (n !== "t.me")
      throw new y(`Link has unexpected hostname: ${n}`);
    const a = r.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new y(
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , s] = a;
  } else
    s = e, o = t;
  return p(dt, "invoice_closed", {
    ...o,
    params: { slug: s },
    capture: (n) => s === n.slug
  }).then((n) => n.status);
}
const [
  Qr,
  Kr,
  Yr
] = b(Wr, "Invoice is already opened"), Xr = Gr("open", Qr), [, Zr, Jr] = Kr, [, ea] = Yr, Qu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Jr,
  isSupported: zr,
  open: Xr,
  openError: ea,
  openPromise: Zr
}, Symbol.toStringTag, { value: "Module" })), J = "locationManager", mt = "web_app_check_location", io = "web_app_open_location_settings", be = /* @__PURE__ */ G({
  available: !1,
  accessGranted: !1,
  accessRequested: !1
});
function _t(e) {
  return /* @__PURE__ */ c(() => be()[e]);
}
const ta = v(mt), oa = _t("available"), sa = _t("accessGranted"), na = _t("accessRequested");
function ra(e) {
  let t = !1, o, s;
  return e.available && (t = !0, o = e.access_requested, s = e.access_granted), {
    available: t,
    accessGranted: s || !1,
    accessRequested: o || !1
  };
}
const [
  aa,
  ia,
  ca,
  Ko
] = /* @__PURE__ */ pe(
  J,
  (e) => {
    const t = w() && S(J);
    return t ? f.resolve(t) : p("web_app_check_location", "location_checked", e).then(ra);
  },
  (e) => {
    be.set(e), M(J, e);
  }
), Yo = C(J, mt), ua = O(J, Ko[0], mt), la = Yo("mount", aa), [, pa, da] = ia, [, ma] = ca, [_a, fa] = Ko, [
  ha,
  ba,
  ga
] = b(
  (e) => p("web_app_request_location", "location_requested", e).then((t) => {
    if (!t.available)
      throw be.set({ ...be(), available: !1 }), new Po("Location data tracking is not available");
    const { available: o, ...s } = t;
    return s;
  }),
  "Location request is currently in progress"
), Ea = ua("requestLocation", ha), [, Xo, Sa] = ba, [, wa] = ga, Ca = Yo("openSettings", () => {
  i(io);
}, io);
function $a() {
  W(Xo), _a.set(!1);
}
const Ku = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isAccessGranted: sa,
  isAccessRequested: na,
  isAvailable: oa,
  isMounted: fa,
  isMounting: da,
  isRequestingLocation: Sa,
  isSupported: ta,
  mount: la,
  mountError: ma,
  mountPromise: pa,
  openSettings: Ca,
  requestLocation: Ea,
  requestLocationError: wa,
  requestLocationPromise: Xo,
  unmount: $a
}, Symbol.toStringTag, { value: "Module" }));
function ft(e) {
  const t = {};
  for (const o in e) {
    const s = e[o];
    s !== void 0 && (t[o] = s);
  }
  return t;
}
function Zo(e) {
  const t = yn(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((o, s, n) => {
      const r = parseInt(t.slice(1 + n * 2, 1 + (n + 1) * 2), 16);
      return o + r * r * s;
    }, 0)
  ) < 120;
}
const [Fe, Ma] = /* @__PURE__ */ u(!1), [N, Q] = /* @__PURE__ */ u({});
function h(e) {
  return /* @__PURE__ */ c(() => N()[e]);
}
const Aa = h("accent_text_color"), Jo = h("bg_color"), ht = h("button_color"), es = h("button_text_color"), va = h("bottom_bar_bg_color"), ya = h("destructive_text_color"), Ba = h("header_bg_color"), Pa = h("hint_color"), Ta = /* @__PURE__ */ c(() => {
  const e = Jo();
  return !e || Zo(e);
}), ka = h("link_color"), ts = h("secondary_bg_color"), Oa = h("section_bg_color"), Ia = h("section_header_text_color"), qa = h("section_separator_color"), Va = h("subtitle_text_color"), xa = h("text_color");
function L(e) {
  return /* @__PURE__ */ c(() => bt()[e]);
}
const ee = /* @__PURE__ */ G({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), bt = /* @__PURE__ */ c(() => {
  const e = ee();
  return {
    ...e,
    backgroundColor: e.backgroundColor || ht() || "#2481cc",
    textColor: e.textColor || es() || "#ffffff"
  };
}), [Ye, os] = /* @__PURE__ */ u(!1), Na = L("backgroundColor"), Da = L("hasShineEffect"), Ha = L("isEnabled"), La = L("isLoaderVisible"), Ra = L("isVisible"), ja = L("text"), Fa = L("textColor"), Ua = "web_app_setup_main_button", ss = "main_button_pressed", Pe = "mainButton", gt = I(Pe), Ga = ye(Pe, os), za = gt("mount", () => {
  if (!Ye()) {
    const e = w() && S(Pe);
    e && ee.set(e), Ye.set(!0);
  }
}), Wa = gt(
  "onClick",
  (e) => d(ss, e)
), Qa = gt(
  "offClick",
  (e) => {
    E(ss, e);
  }
), Ka = Ga(
  "setParams",
  (e) => {
    ee.set({ ...ee(), ...ft(e) }), M(Pe, ee());
    const t = bt();
    t.text && i(Ua, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function Ya() {
  Ye.set(!1);
}
const Yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Na,
  hasShineEffect: Da,
  isEnabled: Ha,
  isLoaderVisible: La,
  isMounted: os,
  isVisible: Ra,
  mount: za,
  offClick: Qa,
  onClick: Wa,
  setParams: Ka,
  state: bt,
  text: ja,
  textColor: Fa,
  unmount: Ya
}, Symbol.toStringTag, { value: "Module" }));
function Et(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function St(e) {
  document.documentElement.style.removeProperty(e);
}
const U = "themeParams", wt = "theme_changed", ns = I(U), Ct = ({ theme_params: e }) => {
  N.set(e), M(U, e);
}, [
  Xa,
  rs,
  Za,
  as
] = /* @__PURE__ */ pe(
  U,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  (e) => f.resolve(
    w() && S(U) || le().tgWebAppThemeParams || {}
  ),
  (e) => {
    d(wt, Ct), N.set(e);
  }
), Ja = ye(U, as[0]), ei = Ja(
  "bindCssVars",
  (e) => {
    if (Fe())
      throw new ot();
    e || (e = (s) => `--tg-theme-${hn(s)}`);
    function t(s) {
      Object.entries(N()).forEach(([n, r]) => {
        r && s(n, r);
      });
    }
    function o() {
      t((s, n) => {
        Et(e(s), n);
      });
    }
    return o(), N.sub(o), Fe.set(!0), () => {
      t(St), N.unsub(o), Fe.set(!1);
    };
  }
), is = ns("mount", Xa), ti = rs[2], cs = rs[1], oi = Za[1], [Xe, si] = as, us = ns("mountSync", () => {
  if (!Xe()) {
    const e = w() && S(U) || le().tgWebAppThemeParams || {};
    d(wt, Ct), se(() => {
      N.set(e), Xe.set(!0);
    });
  }
});
function ni() {
  W(cs), E(wt, Ct), Xe.set(!1);
}
// @__NO_SIDE_EFFECTS__
function ls(e) {
  return /* @__PURE__ */ c(() => Te(e()));
}
function Te(e) {
  return we(e) ? e : Q()[e];
}
const [ae, ri] = /* @__PURE__ */ u("bg_color"), $t = /* @__PURE__ */ ls(ae), [ie, ai] = /* @__PURE__ */ u("bottom_bar_bg_color"), Mt = /* @__PURE__ */ c(() => {
  const e = ie();
  return we(e) ? e : Q()[e] || ts();
}), [ce, ii] = /* @__PURE__ */ u("bg_color"), ps = /* @__PURE__ */ ls(ce), [Ue, ci] = /* @__PURE__ */ u(!1), ui = /* @__PURE__ */ c(() => {
  const e = $t();
  return e ? Zo(e) : !1;
}), [ke, li] = /* @__PURE__ */ u(!0), ds = /* @__PURE__ */ c(() => ({
  backgroundColor: ae(),
  bottomBarColor: ie(),
  headerColor: ce(),
  isActive: ke()
})), Xu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: Aa,
  backgroundColor: Jo,
  bindCssVars: ei,
  bottomBarBgColor: va,
  buttonColor: ht,
  buttonTextColor: es,
  destructiveTextColor: ya,
  headerBackgroundColor: Ba,
  hintColor: Pa,
  isCssVarsBound: Ma,
  isDark: Ta,
  isMounted: si,
  isMounting: ti,
  linkColor: ka,
  mount: is,
  mountError: oi,
  mountPromise: cs,
  mountSync: us,
  secondaryBackgroundColor: ts,
  sectionBackgroundColor: Oa,
  sectionHeaderTextColor: Ia,
  sectionSeparatorColor: qa,
  state: Q,
  subtitleTextColor: Va,
  textColor: xa,
  unmount: ni
}, Symbol.toStringTag, { value: "Module" })), ge = "web_app_set_background_color", Ee = "web_app_set_bottom_bar_color", x = "web_app_set_header_color", At = "visibility_changed", D = "miniApp", vt = {
  any: [
    ge,
    Ee,
    x
  ]
}, pi = /* @__PURE__ */ c(() => vt.any.some((e) => oe(e, k()))), yt = (e) => {
  ke.set(e.is_visible), Ie();
}, Bt = (e) => {
  [
    [ce, x],
    [ae, ge],
    [ie, Ee]
  ].forEach(([t, o]) => {
    const s = t();
    if (!we(s) && // Header color setter uses additional checks. We don't apply changes if the current
    // value is a known color key because it updates automatically by itself.
    (o !== x || s !== "bg_color" && s !== "secondary_bg_color")) {
      const n = e[s];
      n && i(o, { color: n });
    }
  });
}, [
  di,
  ms,
  mi,
  _s
] = /* @__PURE__ */ pe(
  D,
  (e) => is(e).then(() => w() && S(D) || void 0),
  (e) => {
    Pt.ifAvailable(e ? e.backgroundColor : "bg_color"), Tt.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), kt.ifAvailable(e ? e.headerColor : "bg_color"), ke.set(e ? e.isActive : !0), d(At, yt), Q.sub(Bt);
  }
), fs = I(D), hs = C(D, vt), Oe = O(D, _s[0], vt), _i = Oe(
  "bindCssVars",
  (e) => {
    if (Ue())
      throw new ot();
    const [t, o] = tt();
    function s(n, r) {
      function a() {
        Et(n, r() || null);
      }
      a(), t(r.sub(a), St.bind(null, n));
    }
    return e || (e = (n) => `--tg-${Co(n)}`), s(e("bgColor"), $t), s(e("bottomBarColor"), Mt), s(e("headerColor"), ps), t(() => {
      Ue.set(!1);
    }), Ue.set(!0), o;
  }
), fi = fs("close", (e) => {
  i("web_app_close", { return_back: e });
}), hi = hs("mount", di), bi = ms[2], bs = ms[1], gi = mi[1], [Ze, Ei] = _s, Si = hs("mountSync", () => {
  if (!Ze()) {
    us();
    const e = w() && S(D) || void 0;
    Pt.ifAvailable(e ? e.backgroundColor : "bg_color"), Tt.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), kt.ifAvailable(e ? e.headerColor : "bg_color"), d(At, yt), Q.sub(Bt), se(() => {
      ke.set(e ? e.isActive : !0), Ze.set(!0);
    });
  }
}), wi = fs("ready", () => {
  i("web_app_ready");
});
function Ie() {
  M(D, ds());
}
const Pt = Oe(
  "setBackgroundColor",
  (e) => {
    if (e === ae())
      return;
    const t = Te(e);
    if (!t)
      throw new st(e);
    i(ge, { color: t }), ae.set(e), Ie();
  },
  ge
), Tt = Oe(
  "setBottomBarColor",
  (e) => {
    if (e === ie())
      return;
    const t = Te(e);
    if (!t)
      throw new st(e);
    i(Ee, { color: t }), ie.set(e), Ie();
  },
  Ee
), kt = Oe(
  "setHeaderColor",
  (e) => {
    if (e !== ce()) {
      if (e === "bg_color" || e === "secondary_bg_color")
        i(x, { color_key: e });
      else {
        const t = Te(e);
        if (!t)
          throw new st(e);
        i(x, { color: t });
      }
      ce.set(e), Ie();
    }
  },
  x,
  {
    rgb: [x, "color", we]
  }
);
function Ci() {
  W(bs), E(At, yt), Q.unsub(Bt), Ze.set(!1);
}
const Zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: ri,
  backgroundColorRGB: $t,
  bindCssVars: _i,
  bottomBarColor: ai,
  bottomBarColorRGB: Mt,
  close: fi,
  headerColor: ii,
  headerColorRGB: ps,
  isActive: li,
  isCssVarsBound: ci,
  isDark: ui,
  isMounted: Ei,
  isMounting: bi,
  isSupported: pi,
  mount: hi,
  mountError: gi,
  mountPromise: bs,
  mountSync: Si,
  ready: wi,
  setBackgroundColor: Pt,
  setBottomBarColor: Tt,
  setHeaderColor: kt,
  state: ds,
  unmount: Ci
}, Symbol.toStringTag, { value: "Module" }));
function $i(e) {
  const t = e.message.trim(), o = (e.title || "").trim(), s = e.buttons || [];
  if (o.length > 64)
    throw new y(`Invalid title: ${o}`);
  if (!t || t.length > 256)
    throw new y(`Invalid message: ${t}`);
  if (s.length > 3)
    throw new y(`Invalid buttons count: ${s.length}`);
  return {
    title: o,
    message: t,
    buttons: s.length ? s.map((n, r) => {
      const a = n.id || "";
      if (a.length > 64)
        throw new y(`Button with index ${r} has invalid id: ${a}`);
      if (!n.type || n.type === "default" || n.type === "destructive") {
        const m = n.text.trim();
        if (!m || m.length > 64)
          throw new y(`Button with index ${r} has invalid text: ${m}`);
        return { type: n.type, text: m, id: a };
      }
      return { type: n.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const Ot = "web_app_open_popup", gs = C("popup", Ot), Mi = v(Ot), [Es, It, Ss] = b(
  (e) => p(Ot, "popup_closed", {
    ...e,
    params: $i(e)
  }).then(({ button_id: t }) => t === void 0 ? null : t),
  "A popup is already opened"
), Ai = gs("open", Es), vi = It[1], yi = It[2], Bi = Ss[1], Pi = gs("show", Es), [, Ti, ki] = It, [, Oi] = Ss, Ju = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: yi,
  isShown: ki,
  isSupported: Mi,
  open: Ai,
  openError: Bi,
  openPromise: vi,
  show: Pi,
  showError: Oi,
  showPromise: Ti
}, Symbol.toStringTag, { value: "Module" })), ws = "web_app_close_scan_qr_popup", qt = "web_app_open_scan_qr_popup", Ii = "scan_qr_popup_closed", qi = "qr_text_received", Cs = C("qrScanner", qt), Vi = Cs("close", () => {
  i(ws), W($s);
}), xi = v(qt);
function Ni(e) {
  e || (e = {});
  const { onCaptured: t, text: o, capture: s } = e, [, n] = tt(
    d(Ii, () => {
      r.resolve();
    }),
    d(qi, (a) => {
      t ? t(a.data) : (!s || s(a.data)) && (r.resolve(a.data), i(ws));
    })
  ), r = new Sn(e);
  return (e.postEvent || i)(qt, { text: o }), f.resolve(r).catch(Io).finally(n);
}
const [
  Di,
  Hi,
  Li
] = b(Ni, "The QR Scanner is already opened"), Ri = Cs("open", Di), [, $s, ji] = Hi, [, Fi] = Li, el = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: Vi,
  isOpened: ji,
  isSupported: xi,
  open: Ri,
  openError: Fi,
  openPromise: $s
}, Symbol.toStringTag, { value: "Module" }));
function q(e) {
  return /* @__PURE__ */ c(() => Vt()[e]);
}
const te = /* @__PURE__ */ G({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), Vt = /* @__PURE__ */ c(() => {
  const e = te();
  return {
    ...e,
    backgroundColor: e.backgroundColor || Mt() || "#000000",
    textColor: e.textColor || ht() || "#2481cc"
  };
}), [Je, Ms] = /* @__PURE__ */ u(!1), Ui = q("backgroundColor"), Gi = q("hasShineEffect"), zi = q("isEnabled"), Wi = q("isLoaderVisible"), Qi = q("isVisible"), Ki = q("position"), Yi = q("text"), Xi = q("textColor"), qe = "web_app_setup_secondary_button", As = "secondary_button_pressed", Ve = "secondaryButton", xt = C(Ve, qe), Zi = O(Ve, Ms, qe), Ji = v(qe), ec = xt("mount", () => {
  if (!Je()) {
    const e = w() && S(Ve);
    e && te.set(e), Je.set(!0);
  }
}), tc = xt(
  "onClick",
  (e) => d(As, e)
), oc = xt(
  "offClick",
  (e) => {
    E(As, e);
  }
), sc = Zi(
  "setParams",
  (e) => {
    te.set({ ...te(), ...ft(e) }), M(Ve, te());
    const t = Vt();
    t.text && i(qe, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      position: t.position,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function nc() {
  Je.set(!1);
}
const tl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Ui,
  hasShineEffect: Gi,
  isEnabled: zi,
  isLoaderVisible: Wi,
  isMounted: Ms,
  isSupported: Ji,
  isVisible: Qi,
  mount: ec,
  offClick: oc,
  onClick: tc,
  position: Ki,
  setParams: sc,
  state: Vt,
  text: Yi,
  textColor: Xi,
  unmount: nc
}, Symbol.toStringTag, { value: "Module" })), xe = "web_app_setup_settings_button", vs = "settings_button_pressed", Ne = "settingsButton", [co, rc] = /* @__PURE__ */ u(!1), [Se, ac] = /* @__PURE__ */ u(!1), ic = v(xe), Nt = C(Ne, xe), ys = O(Ne, Se, xe), cc = ys("hide", () => {
  Dt(!1);
}), uc = Nt("mount", () => {
  Se() || (Dt(w() && S(Ne) || !1), Se.set(!0));
});
function Dt(e) {
  e !== co() && (i(xe, { is_visible: e }), M(Ne, e), co.set(e));
}
const lc = Nt(
  "onClick",
  (e) => d(vs, e)
), pc = Nt(
  "offClick",
  (e) => {
    E(vs, e);
  }
), dc = ys("show", () => {
  Dt(!0);
});
function mc() {
  Se.set(!1);
}
const ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: cc,
  isMounted: ac,
  isSupported: ic,
  isVisible: rc,
  mount: uc,
  offClick: pc,
  onClick: lc,
  show: dc,
  unmount: mc
}, Symbol.toStringTag, { value: "Module" })), De = "web_app_setup_swipe_behavior", He = "swipeBehavior", [ue, _c] = /* @__PURE__ */ u(!1), fc = v(De), [et, hc] = /* @__PURE__ */ u(!0), bc = C(He, De), Bs = O(He, ue, De), gc = Bs("disableVertical", () => {
  Ht(!1);
}), Ec = Bs("enableVertical", () => {
  Ht(!0);
}), Sc = bc("mount", () => {
  ue() || (Ht(
    w() && S(He) || !1,
    !0
  ), ue.set(!0));
});
function Ht(e, t) {
  (e !== et() || t) && (i(De, { allow_vertical_swipe: e }), M(He, e), et.set(e));
}
function wc() {
  ue.set(!1);
}
const sl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _isMounted: ue,
  _isVerticalEnabled: et,
  disableVertical: gc,
  enableVertical: Ec,
  isMounted: _c,
  isSupported: fc,
  isVerticalEnabled: hc,
  mount: Sc,
  unmount: wc
}, Symbol.toStringTag, { value: "Module" })), R = "viewport", Lt = "fullscreen_changed", Rt = "safe_area_changed", jt = "content_safe_area_changed", Ft = "viewport_changed", Ps = I(R), uo = { left: 0, top: 0, bottom: 0, right: 0 };
function Ge(e) {
  return Math.max(e, 0);
}
const [ze, Ts] = /* @__PURE__ */ u({
  contentSafeAreaInsets: uo,
  height: 0,
  isExpanded: !1,
  isFullscreen: !1,
  safeAreaInsets: uo,
  stableHeight: 0,
  width: 0
});
function j(e) {
  return /* @__PURE__ */ c(() => Ts()[e]);
}
const Ut = j("height"), Gt = j("stableHeight"), ks = j("width"), Cc = j("isExpanded"), $c = /* @__PURE__ */ c(() => Ut() === Gt());
function K(e) {
  const { height: t, stableHeight: o, width: s } = e;
  ze.set({
    ...ze(),
    ...ft({
      ...e,
      height: t ? Ge(t) : void 0,
      width: s ? Ge(s) : void 0,
      stableHeight: o ? Ge(o) : void 0
    })
  }), M(R, ze());
}
function Mc() {
  return S(R);
}
function Le(e) {
  return /* @__PURE__ */ c(() => zt()[e]);
}
const zt = j("contentSafeAreaInsets"), Os = Le("bottom"), Is = Le("left"), qs = Le("right"), Vs = Le("top");
function Re(e) {
  return /* @__PURE__ */ c(() => Wt()[e]);
}
const Wt = j("safeAreaInsets"), xs = Re("bottom"), Ns = Re("left"), Ds = Re("right"), Hs = Re("top"), Ls = "web_app_request_safe_area", Rs = C(R, Ls), lo = Rs(
  "requestContentSafeAreaInsets",
  (e) => p("web_app_request_content_safe_area", jt, e)
);
function Ac(e) {
  return p("web_app_request_viewport", Ft, e);
}
const po = Rs(
  "requestSafeAreaInsets",
  (e) => p(Ls, Rt, e)
), js = (e) => {
  const { height: t } = e;
  K({
    isExpanded: e.is_expanded,
    height: t,
    width: e.width,
    stableHeight: e.is_state_stable ? t : void 0
  });
}, Fs = (e) => {
  K({ isFullscreen: e.is_fullscreen });
}, Us = (e) => {
  K({ safeAreaInsets: e });
}, Gs = (e) => {
  K({ contentSafeAreaInsets: e });
}, [
  vc,
  yc,
  Bc,
  Pc
] = /* @__PURE__ */ pe(
  R,
  (e) => {
    const t = w() && Mc();
    return t ? f.resolve(t) : f.fn(async (o) => {
      const s = await f.all([
        po.isAvailable() ? po(o) : Wt(),
        lo.isAvailable() ? lo(o) : zt()
      ]), n = le(), r = {
        contentSafeAreaInsets: s[1],
        isFullscreen: !!n.tgWebAppFullscreen,
        safeAreaInsets: s[0]
      };
      if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(n.tgWebAppPlatform)) {
        const a = window;
        return {
          ...r,
          height: a.innerHeight,
          isExpanded: !0,
          stableHeight: a.innerHeight,
          width: a.innerWidth
        };
      }
      return Ac(o).then((a) => ({
        ...r,
        height: a.height,
        isExpanded: a.is_expanded,
        stableHeight: a.is_state_stable ? a.height : 0,
        width: a.width
      }));
    }, e);
  },
  (e) => {
    d(Ft, js), d(Lt, Fs), d(Rt, Us), d(jt, Gs), K(e);
  }
), Tc = Ps("mount", vc), [, zs, kc] = yc, [, Oc] = Bc, [Qt, Ic] = Pc;
function qc() {
  W(zs), E(Ft, js), E(Lt, Fs), E(Rt, Us), E(jt, Gs), Qt.set(!1);
}
const Vc = ye(R, Qt), [We, xc] = /* @__PURE__ */ u(!1), Nc = Vc(
  "bindCssVars",
  (e) => {
    if (We())
      throw new ot();
    e || (e = (o) => `--tg-viewport-${Co(o)}`);
    const t = [
      ["height", Ut],
      ["stableHeight", Gt],
      ["width", ks],
      ["safeAreaInsetTop", Hs],
      ["safeAreaInsetBottom", xs],
      ["safeAreaInsetLeft", Ns],
      ["safeAreaInsetRight", Ds],
      ["contentSafeAreaInsetTop", Vs],
      ["contentSafeAreaInsetBottom", Os],
      ["contentSafeAreaInsetLeft", Is],
      ["contentSafeAreaInsetRight", qs]
    ].reduce((o, [s, n]) => {
      const r = e(s);
      if (r) {
        const a = () => {
          Et(r, `${n()}px`);
        };
        o.push([a, n.sub(a), r]);
      }
      return o;
    }, []);
    return t.forEach((o) => {
      o[0]();
    }), We.set(!0), () => {
      t.forEach((o) => {
        o[1](), St(o[2]);
      }), We.set(!1);
    };
  }
), Dc = Ps("expand", () => {
  i("web_app_expand");
}), Ws = "web_app_request_fullscreen", Hc = O(R, Qt, Ws), Qs = j("isFullscreen"), [
  Lc,
  Rc
] = /* @__PURE__ */ u(), [
  jc,
  Fc
] = /* @__PURE__ */ u();
function Ks(e, t) {
  return Hc(
    e,
    b(
      (o) => p(
        t ? Ws : "web_app_exit_fullscreen",
        [Lt, "fullscreen_failed"],
        o
      ).then((s) => {
        if ("error" in s && s.error !== "ALREADY_FULLSCREEN")
          throw new In(s.error);
        const n = "is_fullscreen" in s ? s.is_fullscreen : !0;
        n !== Qs() && K({ isFullscreen: n });
      }),
      "Fullscreen mode change is already being requested",
      {
        promise: Lc,
        error: jc
      }
    )[0]
  );
}
const Uc = Ks("requestFullscreen", !0), Gc = Ks("exitFullscreen"), nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: Nc,
  changeFullscreenError: Fc,
  changeFullscreenPromise: Rc,
  contentSafeAreaInsetBottom: Os,
  contentSafeAreaInsetLeft: Is,
  contentSafeAreaInsetRight: qs,
  contentSafeAreaInsetTop: Vs,
  contentSafeAreaInsets: zt,
  exitFullscreen: Gc,
  expand: Dc,
  height: Ut,
  isCssVarsBound: xc,
  isExpanded: Cc,
  isFullscreen: Qs,
  isMounted: Ic,
  isMounting: kc,
  isStable: $c,
  mount: Tc,
  mountError: Oc,
  mountPromise: zs,
  requestFullscreen: Uc,
  safeAreaInsetBottom: xs,
  safeAreaInsetLeft: Ns,
  safeAreaInsetRight: Ds,
  safeAreaInsetTop: Hs,
  safeAreaInsets: Wt,
  stableHeight: Gt,
  state: Ts,
  unmount: qc,
  width: ks
}, Symbol.toStringTag, { value: "Module" })), Ys = "web_app_request_emoji_status_access", [
  zc,
  Wc,
  Qc
] = b((e) => p(Ys, "emoji_status_access_requested", e).then((t) => t.status), "Emoji status access request is already in progress"), rl = /* @__PURE__ */ l(
  "requestEmojiStatusAccess",
  zc,
  { isSupported: Ys }
), [, al, il] = Wc, [, cl] = Qc, Xs = "web_app_set_emoji_status", [
  Kc,
  Yc,
  Xc
] = b(
  (e, t) => p(Xs, ["emoji_status_set", "emoji_status_failed"], {
    params: {
      custom_emoji_id: e,
      duration: (t || {}).duration
    },
    ...t
  }).then((o) => {
    if (o && "error" in o)
      throw new On(o.error);
  }),
  "Emoji status set request is currently in progress"
), ul = /* @__PURE__ */ l("setEmojiStatus", Kc, {
  isSupported: Xs
}), [, ll, pl] = Yc, [, dl] = Xc, Zc = { isSupported: "web_app_add_to_home_screen" }, Zs = "home_screen_failed", ml = /* @__PURE__ */ l(
  "onAddToHomeScreenFailed",
  (e, t) => d(Zs, e, t),
  { isSupported: "web_app_add_to_home_screen" }
), _l = /* @__PURE__ */ l(
  "offAddToHomeScreenFailed",
  (e) => {
    E(Zs, e);
  },
  Zc
), Js = { isSupported: "web_app_add_to_home_screen" }, en = "home_screen_added", fl = /* @__PURE__ */ l(
  "onAddedToHomeScreen",
  (e, t) => d(en, e, t),
  Js
), hl = /* @__PURE__ */ l(
  "offAddedToHomeScreen",
  (e) => {
    E(en, e);
  },
  Js
), mo = "web_app_add_to_home_screen", bl = /* @__PURE__ */ l(
  "addToHomeScreen",
  () => {
    i(mo);
  },
  { isSupported: mo }
), tn = "web_app_check_home_screen", [
  Jc,
  eu,
  tu
] = b((e) => p(tn, "home_screen_checked", e).then((t) => t.status || "unknown"), "Check home screen status request is currently in progress"), gl = /* @__PURE__ */ l("checkHomeScreenStatus", Jc, {
  isSupported: tn
}), [, El, Sl] = eu, [, wl] = tu, ou = I(), Cl = ou(
  "openLink",
  (e, t) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (o) {
        throw new y(`"${e.toString()}" is invalid URL`, o);
      }
    t || (t = {}), i("web_app_open_link", {
      url: e.toString(),
      try_browser: t.tryBrowser,
      try_instant_view: t.tryInstantView
    });
  }
), _o = "web_app_open_tg_link", su = I(), nu = su(
  "openTelegramLink",
  (e) => {
    const t = e.toString();
    if (!t.match(/^https:\/\/t.me\/.+/))
      throw new y(`"${t}" is invalid URL`);
    if (!oe(_o, k())) {
      window.location.href = t;
      return;
    }
    e = new URL(e), i(_o, { path_full: e.pathname + e.search });
  }
), ru = I(), $l = ru(
  "shareURL",
  (e, t) => {
    nu(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t || "" }).toString().replace(/\+/g, "%20")
    );
  }
);
function au(e, t) {
  return new f({ abortSignal: t, timeout: e }).catch(() => {
  });
}
const on = "web_app_request_phone", [
  iu,
  cu,
  uu
] = b((e) => p(on, "phone_requested", e).then((t) => t.status), "Phone access request is currently in progress"), lu = /* @__PURE__ */ l("requestPhoneAccess", iu, {
  isSupported: on
}), [, Ml, Al] = cu, [, vl] = uu, sn = {
  isSupported: "web_app_request_phone"
};
async function fo(e) {
  const t = ne($(), await z("getRequestedContact", {}, {
    ...e,
    timeout: (e || {}).timeout || 5e3
  }));
  return {
    raw: t,
    parsed: ne(
      fe(
        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.
        $n([$(), Mn(URLSearchParams)]),
        Bn(
          to({
            contact: fe(
              $(),
              Pn(),
              to({
                user_id: $o(),
                phone_number: $(),
                first_name: $(),
                last_name: An($())
              })
            ),
            auth_date: fe(
              $(),
              Mo((o) => new Date(Number(o) * 1e3)),
              Ao()
            ),
            hash: $()
          })
        )
      ),
      t
    )
  };
}
const [pu, du, mu] = b(
  (e) => new f(
    async (t, o, s) => {
      try {
        return t(await fo(s));
      } catch (a) {
        if (a instanceof eo)
          throw a;
      }
      if (await lu(s) !== "sent")
        throw new To("User denied access");
      let r = 50;
      for (; !s.isAborted(); ) {
        try {
          return t(await fo(s));
        } catch (a) {
          if (a instanceof eo)
            throw a;
        }
        await au(r), r += 50;
      }
    },
    e
  ),
  "Contact is already being requested"
), _u = /* @__PURE__ */ l("requestContactComplete", pu, sn), yl = /* @__PURE__ */ l(
  "requestContact",
  (e) => _u(e).then((t) => t.parsed),
  sn
), [, Bl, Pl] = du, [, Tl] = mu, nn = "web_app_request_write_access", [
  fu,
  hu,
  bu
] = b(
  (e) => p(nn, "write_access_requested", e).then((t) => t.status),
  "Write access request is currently in progress"
), kl = /* @__PURE__ */ l("requestWriteAccess", fu, {
  isSupported: nn
}), [, Ol, Il] = hu, [, ql] = bu;
function gu(e) {
  const t = document.createElement("textarea");
  t.value = e, t.style.top = "0", t.style.left = "0", t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(t);
  }
}
async function Vl(e) {
  try {
    const { clipboard: t } = navigator;
    if (t)
      return await t.writeText(e);
  } catch {
  }
  gu(e);
}
const ho = "web_app_request_file_download", xl = /* @__PURE__ */ l(
  "downloadFile",
  (e, t, o) => p(
    ho,
    "file_download_requested",
    { ...o, params: { url: e, file_name: t } }
  ).then((s) => {
    if (s.status !== "downloading")
      throw new To("User denied the action");
  }),
  { isSupported: ho }
), Nl = /* @__PURE__ */ l(
  "getCurrentTime",
  (e) => z("getCurrentTime", {}, e).then((t) => ne(
    fe($o(), vn(), Mo((o) => new Date(o * 1e3)), Ao()),
    t
  )),
  { isSupported: "web_app_invoke_custom_method" }
), bo = "web_app_read_text_from_clipboard", Dl = /* @__PURE__ */ l(
  "readTextFromClipboard",
  (e) => {
    const t = Bo();
    return p(bo, "clipboard_text_received", {
      ...e,
      params: { req_id: t },
      capture: _n(t)
    }).then(({ data: o = null }) => o);
  },
  { isSupported: bo }
), go = "web_app_data_send", Hl = /* @__PURE__ */ l(
  "sendData",
  (e) => {
    const { size: t } = new Blob([e]);
    if (!t || t > 4096)
      throw new y(t ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    i(go, { data: e });
  },
  { isSupported: go }
), Eo = "web_app_send_prepared_message", Ll = /* @__PURE__ */ l(
  "shareMessage",
  (e, t) => p(Eo, ["prepared_message_failed", "prepared_message_sent"], {
    ...t,
    params: { id: e }
  }).then((o) => {
    if (o && "error" in o)
      throw new qn(o.error);
  }),
  { isSupported: Eo }
), So = "web_app_share_to_story", Rl = /* @__PURE__ */ l(
  "shareStory",
  (e, t) => {
    t || (t = {}), i(So, {
      text: t.text,
      media_url: e,
      widget_link: t.widgetLink
    });
  },
  { isSupported: So }
), Eu = "web_app_switch_inline_query", jl = /* @__PURE__ */ l(
  "switchInlineQuery",
  (e, t) => {
    i(Eu, {
      query: e,
      chat_types: t || []
    });
  },
  {
    isSupported() {
      return le().tgWebAppBotInline ? void 0 : "The application must be launched in the inline mode";
    }
  }
);
function Fl(e) {
  try {
    return [!0, e()];
  } catch (t) {
    return [!1, t];
  }
}
function Ul(e) {
  Tn(e);
  const [t, o] = tt(
    d("reload_iframe", () => {
      Qe(!1, "Received a request to reload the page"), i("iframe_will_reload"), window.location.reload();
    })
  ), { acceptCustomStyles: s = !0 } = e || {};
  if (s) {
    const n = document.createElement("style");
    n.id = "telegram-custom-styles", document.head.appendChild(n), t(
      d("set_custom_style", (r) => {
        n.innerHTML = r;
      }),
      () => {
        document.head.removeChild(n);
      }
    );
  }
  return i("iframe_ready", { reload_supported: !0 }), Qe(!1, "The package was initialized"), o;
}
export {
  Wl as AbortablePromise,
  To as AccessDeniedError,
  ot as CSSVarsBoundError,
  Ql as CancelledError,
  kn as ConcurrentCallError,
  In as FullscreenFailedError,
  Z as FunctionUnavailableError,
  y as InvalidArgumentsError,
  Ou as InvalidEnvError,
  Kl as InvalidLaunchParamsError,
  Yl as InvokeCustomMethodError,
  Xl as LaunchParamsRetrieveError,
  Zl as ManualPromise,
  Jl as MethodParameterUnsupportedError,
  ep as MethodUnsupportedError,
  Po as NotAvailableError,
  On as SetEmojiStatusError,
  qn as ShareMessageError,
  tp as TimeoutError,
  op as UnknownEnvError,
  st as UnknownThemeParamsKeyError,
  bl as addToHomeScreen,
  rr as authenticateBiometry,
  ju as backButton,
  _i as bindMiniAppCssVars,
  ei as bindThemeParamsCssVars,
  Nc as bindViewportCssVars,
  Fu as biometry,
  ir as biometryAuthError,
  Ho as biometryAuthPromise,
  Jn as biometryMountError,
  Un as biometryState,
  Fc as changeFullscreenError,
  Rc as changeFullscreenPromise,
  gl as checkHomeScreenStatus,
  wl as checkHomeScreenStatusError,
  El as checkHomeScreenStatusPromise,
  fi as closeMiniApp,
  Vi as closeQrScanner,
  Uu as closingBehavior,
  Gu as cloudStorage,
  Tn as configure,
  Vl as copyTextToClipboard,
  sp as createPostEvent,
  Bo as createRequestId,
  Uo as deleteCloudStorageItem,
  Er as disableClosingConfirmation,
  gc as disableVerticalSwipes,
  xl as downloadFile,
  np as emitEvent,
  Sr as enableClosingConfirmation,
  Ec as enableVerticalSwipes,
  Gc as exitFullscreen,
  Dc as expandViewport,
  Ar as getCloudStorageItem,
  Go as getCloudStorageKeys,
  Nl as getCurrentTime,
  zu as hapticFeedback,
  Pr as hapticFeedbackImpactOccurred,
  Tr as hapticFeedbackNotificationOccurred,
  kr as hapticFeedbackSelectionChanged,
  Dn as hideBackButton,
  cc as hideSettingsButton,
  Io as ignoreCanceled,
  Ul as init,
  Wu as initData,
  Wo as initDataAuthDate,
  Qo as initDataCanSendAfter,
  Ir as initDataCanSendAfterDate,
  qr as initDataChat,
  xr as initDataChatInstance,
  Vr as initDataChatType,
  Nr as initDataHash,
  Dr as initDataQueryId,
  Lr as initDataRaw,
  Rr as initDataReceiver,
  Fr as initDataStartParam,
  Or as initDataState,
  Ur as initDataUser,
  Qu as invoice,
  z as invokeCustomMethod,
  Du as isAccessDeniedError,
  ar as isAuthenticatingBiometry,
  xn as isBackButtonMounted,
  Nn as isBackButtonSupported,
  Vn as isBackButtonVisible,
  Gn as isBiometryAvailable,
  tr as isBiometryMounted,
  Zn as isBiometryMounting,
  Wn as isBiometrySupported,
  Tu as isCSSVarsBoundError,
  rp as isCancelledError,
  Sl as isCheckingHomeScreenStatus,
  Ro as isClosingBehaviorMounted,
  br as isClosingConfirmationEnabled,
  $r as isCloudStorageSupported,
  Zo as isColorDark,
  xu as isConcurrentCallError,
  Qs as isFullscreen,
  Hu as isFullscreenFailedError,
  qu as isFunctionNotAvailableError,
  Br as isHapticFeedbackSupported,
  Vu as isInvalidArguments,
  Iu as isInvalidEnvError,
  ap as isInvalidLaunchParamsError,
  Jr as isInvoiceOpened,
  zr as isInvoiceSupported,
  ip as isInvokeCustomMethodError,
  cp as isLaunchParamsRetrieveError,
  sa as isLocationManagerAccessGranted,
  na as isLocationManagerAccessRequested,
  oa as isLocationManagerAvailable,
  fa as isLocationManagerMounted,
  da as isLocationManagerMounting,
  ta as isLocationManagerSupported,
  Ha as isMainButtonEnabled,
  La as isMainButtonLoaderVisible,
  os as isMainButtonMounted,
  Ra as isMainButtonVisible,
  up as isMethodMethodParameterUnsupportedError,
  lp as isMethodUnsupportedError,
  li as isMiniAppActive,
  ci as isMiniAppCssVarsBound,
  ui as isMiniAppDark,
  Ei as isMiniAppMounted,
  bi as isMiniAppMounting,
  pi as isMiniAppSupported,
  ku as isNotAvailableError,
  yi as isPopupOpened,
  ki as isPopupShown,
  Mi as isPopupSupported,
  ji as isQrScannerOpened,
  xi as isQrScannerSupported,
  Ap as isRGB,
  vp as isRGBShort,
  mr as isRequestingBiometryAccess,
  Pl as isRequestingContact,
  il as isRequestingEmojiStatusAccess,
  Sa as isRequestingLocation,
  Al as isRequestingPhoneAccess,
  Il as isRequestingWriteAccess,
  so as isSSR,
  zi as isSecondaryButtonEnabled,
  Wi as isSecondaryButtonLoaderVisible,
  Ms as isSecondaryButtonMounted,
  Ji as isSecondaryButtonSupported,
  Qi as isSecondaryButtonVisible,
  Nu as isSetEmojiStatusError,
  pl as isSettingEmojiStatus,
  ac as isSettingsButtonMounted,
  ic as isSettingsButtonSupported,
  rc as isSettingsButtonVisible,
  Lu as isShareMessageError,
  _c as isSwipeBehaviorMounted,
  fc as isSwipeBehaviorSupported,
  pp as isTMA,
  Ma as isThemeParamsCssVarsBound,
  Ta as isThemeParamsDark,
  si as isThemeParamsMounted,
  ti as isThemeParamsMounting,
  dp as isTimeoutError,
  mp as isUnknownEnvError,
  Ru as isUnknownThemeParamsKeyError,
  hc as isVerticalSwipesEnabled,
  xc as isViewportCssVarsBound,
  Cc as isViewportExpanded,
  Ic as isViewportMounted,
  kc as isViewportMounting,
  $c as isViewportStable,
  Ku as locationManager,
  ma as locationManagerMountError,
  pa as locationManagerMountPromise,
  Yu as mainButton,
  Na as mainButtonBackgroundColor,
  Da as mainButtonHasShineEffect,
  bt as mainButtonState,
  ja as mainButtonText,
  Fa as mainButtonTextColor,
  Zu as miniApp,
  ri as miniAppBackgroundColor,
  $t as miniAppBackgroundColorRGB,
  ai as miniAppBottomBarColor,
  Mt as miniAppBottomBarColorRGB,
  ii as miniAppHeaderColor,
  ps as miniAppHeaderColorRGB,
  gi as miniAppMountError,
  bs as miniAppMountPromise,
  wi as miniAppReady,
  ds as miniAppState,
  _p as mockTelegramEnv,
  Hn as mountBackButton,
  Xn as mountBiometry,
  Do as mountBiometryPromise,
  wr as mountClosingBehavior,
  la as mountLocationManager,
  za as mountMainButton,
  hi as mountMiniApp,
  Si as mountMiniAppSync,
  ec as mountSecondaryButton,
  uc as mountSettingsButton,
  Sc as mountSwipeBehavior,
  is as mountThemeParams,
  us as mountThemeParamsSync,
  Tc as mountViewport,
  fp as off,
  _l as offAddToHomeScreenFailed,
  hl as offAddedToHomeScreen,
  Rn as offBackButtonClick,
  Qa as offMainButtonClick,
  oc as offSecondaryButtonClick,
  pc as offSettingsButtonClick,
  hp as on,
  ml as onAddToHomeScreenFailed,
  fl as onAddedToHomeScreen,
  Ln as onBackButtonClick,
  Wa as onMainButtonClick,
  tc as onSecondaryButtonClick,
  lc as onSettingsButtonClick,
  cr as openBiometrySettings,
  Xr as openInvoice,
  ea as openInvoiceError,
  Zr as openInvoicePromise,
  Cl as openLink,
  Ca as openLocationManagerSettings,
  Ai as openPopup,
  Bi as openPopupError,
  vi as openPopupPromise,
  Ri as openQrScanner,
  Fi as openQrScannerError,
  $s as openQrScannerPromise,
  nu as openTelegramLink,
  yp as parseInitDataQuery,
  Bp as parseLaunchParamsQuery,
  Ju as popup,
  i as postEvent,
  bp as postMessage,
  gp as postMessageImplementation,
  el as qrScanner,
  Dl as readTextFromClipboard,
  p as request,
  zn as requestBiometry,
  dr as requestBiometryAccess,
  _r as requestBiometryAccessError,
  Lo as requestBiometryAccessPromise,
  yl as requestContact,
  _u as requestContactComplete,
  Tl as requestContactError,
  Bl as requestContactPromise,
  lo as requestContentSafeAreaInsets,
  rl as requestEmojiStatusAccess,
  cl as requestEmojiStatusAccessError,
  al as requestEmojiStatusAccessPromise,
  Uc as requestFullscreen,
  Ea as requestLocation,
  wa as requestLocationError,
  Xo as requestLocationPromise,
  lu as requestPhoneAccess,
  vl as requestPhoneAccessError,
  Ml as requestPhoneAccessPromise,
  po as requestSafeAreaInsets,
  Ac as requestViewport,
  kl as requestWriteAccess,
  ql as requestWriteAccessError,
  Ol as requestWriteAccessPromise,
  jr as restoreInitData,
  Ep as retrieveLaunchParams,
  Sp as retrieveRawInitData,
  wp as retrieveRawLaunchParams,
  Fl as safeCall,
  tl as secondaryButton,
  Ui as secondaryButtonBackgroundColor,
  Gi as secondaryButtonHasShineEffect,
  Ki as secondaryButtonPosition,
  Vt as secondaryButtonState,
  Yi as secondaryButtonText,
  Xi as secondaryButtonTextColor,
  Hl as sendData,
  Pp as serializeInitDataQuery,
  Tp as serializeLaunchParamsQuery,
  kp as serializeToQuery,
  vr as setCloudStorageItem,
  Pu as setDebug,
  ul as setEmojiStatus,
  dl as setEmojiStatusError,
  ll as setEmojiStatusPromise,
  Ka as setMainButtonParams,
  Pt as setMiniAppBackgroundColor,
  Tt as setMiniAppBottomBarColor,
  kt as setMiniAppHeaderColor,
  sc as setSecondaryButtonParams,
  ol as settingsButton,
  Ll as shareMessage,
  Rl as shareStory,
  $l as shareURL,
  jn as showBackButton,
  Pi as showPopup,
  Oi as showPopupError,
  Ti as showPopupPromise,
  dc as showSettingsButton,
  Cp as supports,
  sl as swipeBehavior,
  jl as switchInlineQuery,
  $p as targetOrigin,
  Xu as themeParams,
  Aa as themeParamsAccentTextColor,
  Jo as themeParamsBackgroundColor,
  va as themeParamsBottomBarBgColor,
  ht as themeParamsButtonColor,
  es as themeParamsButtonTextColor,
  ya as themeParamsDestructiveTextColor,
  Ba as themeParamsHeaderBackgroundColor,
  Pa as themeParamsHintColor,
  ka as themeParamsLinkColor,
  oi as themeParamsMountError,
  cs as themeParamsMountPromise,
  ts as themeParamsSecondaryBackgroundColor,
  Oa as themeParamsSectionBackgroundColor,
  Ia as themeParamsSectionHeaderTextColor,
  qa as themeParamsSectionSeparatorColor,
  Q as themeParamsState,
  Va as themeParamsSubtitleTextColor,
  xa as themeParamsTextColor,
  Op as toRGB,
  Ip as transformQueryUsing,
  Fn as unmountBackButton,
  fr as unmountBiometry,
  Cr as unmountClosingBehavior,
  $a as unmountLocationManager,
  Ya as unmountMainButton,
  Ci as unmountMiniApp,
  nc as unmountSecondaryButton,
  mc as unmountSettingsButton,
  wc as unmountSwipeBehavior,
  ni as unmountThemeParams,
  qc as unmountViewport,
  hr as updateBiometryToken,
  nl as viewport,
  Os as viewportContentSafeAreaInsetBottom,
  Is as viewportContentSafeAreaInsetLeft,
  qs as viewportContentSafeAreaInsetRight,
  Vs as viewportContentSafeAreaInsetTop,
  zt as viewportContentSafeAreaInsets,
  Ut as viewportHeight,
  Oc as viewportMountError,
  zs as viewportMountPromise,
  xs as viewportSafeAreaInsetBottom,
  Ns as viewportSafeAreaInsetLeft,
  Ds as viewportSafeAreaInsetRight,
  Hs as viewportSafeAreaInsetTop,
  Wt as viewportSafeAreaInsets,
  Gt as viewportStableHeight,
  Ts as viewportState,
  ks as viewportWidth,
  l as wrapSafe
};
//# sourceMappingURL=index.js.map
