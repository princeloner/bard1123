{"version":3,"file":"index.iife.js","sources":["../../../node_modules/.pnpm/valibot@1.0.0_typescript@5.6.3/node_modules/valibot/dist/index.js","../../../node_modules/.pnpm/better-promises@0.4.1/node_modules/better-promises/dist/index.js","../../toolkit/dist/index.js","../../transformers/dist/index.js","../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs","../../../node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js","../../signals/dist/index.js","../../bridge/dist/index.js","../../navigation/dist/index.js","../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/scopes/components/location-manager/location-manager.ts","../src/utils/removeUndefined.ts","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/utils.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/copyTextToClipboard.ts","../src/scopes/utilities/uncategorized/downloadFile.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareMessage.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message !== void 0) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n  const list = [...new Set(values2)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n  const entries = {};\n  for (const schema of schemas) {\n    Object.assign(entries, schema.entries);\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = (\n  // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n  /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n);\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value > this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value < this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) {\n    for (const path of paths) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (\n            // @ts-expect-error\n            path[index] !== issue.path[index].key && // @ts-expect-error\n            (path[index] !== \"$\" || issue.path[index].type !== \"array\")\n          ) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"slug\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  SLUG_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  entriesFromObjects,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  gtValue,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  ltValue,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notValues,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  slug,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  values,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","var V = Object.defineProperty;\nvar Y = (r, t, e) => t in r ? V(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar y = (r, t, e) => Y(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nvar $ = Object.defineProperty, k = (r, t, e) => t in r ? $(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e, q = (r, t, e) => k(r, t + \"\", e);\nfunction z(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction P(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class c extends Error {\n    constructor(...s) {\n      const a = typeof t == \"function\" ? t(...s) : typeof t == \"string\" ? [t] : t || [];\n      super(...a), q(this, \"type\", e), this.name = r;\n    }\n  }\n  return Object.defineProperty(c, \"name\", { value: r }), [c, z(c, e)];\n}\nconst [G, M] = P(\"CancelledError\", \"Promise was canceled\"), [H, N] = P(\n  \"TimeoutError\",\n  (r, t) => [`Timeout reached: ${r}ms`, { cause: t }]\n), B = Symbol(\"Resolved\");\nfunction C(r) {\n  return Array.isArray(r) && r[0] === B;\n}\nfunction J(r) {\n  return [B, r];\n}\nfunction x(r, t) {\n  return r.reject = t.reject, r.abort = t.abort, r;\n}\nclass m extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let v, u;\n      typeof e == \"function\" ? (v = e, u = c) : u = e;\n      const d = [], j = (n) => (...h) => {\n        const p = n(...h);\n        return d.forEach((F) => F()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (n) => {\n        !l.aborted && g.abort(n);\n      };\n      const b = () => l.reason, w = (n) => {\n        const h = () => {\n          n(b());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return d.push(p), p;\n      }, D = j((n) => {\n        a(n), s(J(n));\n      });\n      o = j((n) => {\n        i(n), s(n);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: n } = f;\n          if (A)\n            return o(n);\n          s(n);\n        } else {\n          const n = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", n), d.push(() => {\n            f.removeEventListener(\"abort\", n);\n          });\n        }\n      A && w(i);\n      const { timeout: E } = u;\n      if (E) {\n        const n = setTimeout(() => {\n          s(new H(E));\n        }, E);\n        d.push(() => {\n          clearTimeout(n);\n        });\n      }\n      const L = () => l.aborted, S = () => C(b()), T = () => {\n        const n = b();\n        return C(n) ? n[1] : void 0;\n      };\n      try {\n        const n = v && v(D, o, {\n          abortReason: b,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: S,\n          onAborted: w,\n          onResolved: (h) => w(() => {\n            S() && h(T());\n          }),\n          resolved: T,\n          throwIfAborted() {\n            if (L())\n              throw b();\n          }\n        });\n        n instanceof Promise && n.catch(o);\n      } catch (n) {\n        o(n);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new m(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new m((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new G());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(r, t) {\n  return r.resolve = t.resolve, r;\n}\nclass R extends m {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, v, u) => {\n      a = i, o && o(i, v, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  m as AbortablePromise,\n  G as CancelledError,\n  R as ManualPromise,\n  H as TimeoutError,\n  M as isCancelledError,\n  C as isPromiseResolveResult,\n  N as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ U(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ W(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ N(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ d((n) => e ? w(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ v(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ v(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ d((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ v(\n    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ E(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ E(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ z()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: Q,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: Q\n}), ye = C(le), he = C(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ V(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v(\n      /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ E()]),\n      /* @__PURE__ */ d((e) => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e),\n      /* @__PURE__ */ L(H)\n    )\n  )\n), x = /* @__PURE__ */ c(\n  /* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d((e) => e === \"1\"))\n), G = C(be()), de = /* @__PURE__ */ k({\n  tgWebAppBotInline: x,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(G()),\n  tgWebAppFullscreen: x,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: x,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: G(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(de), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  de as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  C as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  ve as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import { is as h, looseObject as u, function as R, string as w, nullish as d, optional as M, unknown as X, number as x, boolean as S, parse as v, pipe as U, any as Z } from \"valibot\";\nimport { AbortablePromise as $ } from \"better-promises\";\nimport { AbortablePromise as Qe, CancelledError as Be, ManualPromise as Ke, TimeoutError as Ye, isCancelledError as Fe, isTimeoutError as He } from \"better-promises\";\nimport { createLogger as O, createCbCollector as V, getStorageValue as ee, setStorageValue as j, deepSnakeToCamelObjKeys as te } from \"@telegram-apps/toolkit\";\nimport { themeParams as re, jsonParse as z, MiniAppsMessageSchema as D, isLaunchParamsQuery as N, parseLaunchParamsQuery as y, serializeLaunchParamsQuery as oe } from \"@telegram-apps/transformers\";\nimport ne from \"mitt\";\nimport { errorClass as b, errorClassWithData as ae } from \"error-kid\";\nimport { signal as G } from \"@telegram-apps/signals\";\nfunction J(e) {\n  return h(\n    u({ TelegramWebviewProxy: u({ postEvent: R() }) }),\n    e\n  );\n}\nfunction Q() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nfunction se(e, t) {\n  const r = ne(), o = /* @__PURE__ */ new Map(), s = (n, a, c) => {\n    c || (c = !1);\n    const i = o.get(n) || /* @__PURE__ */ new Map();\n    o.set(n, i);\n    const _ = i.get(a) || [];\n    i.set(a, _);\n    const l = _.findIndex((f) => f[1] === c);\n    l >= 0 && (r.off(n, _[l][0]), _.splice(l, 1), !_.length && i.delete(a), i.size || (o.delete(n), !o.size && t()));\n  };\n  return [\n    function(a, c, i) {\n      !o.size && e();\n      function _() {\n        s(a, c, i);\n      }\n      function l(...k) {\n        i && _(), a === \"*\" ? c(k) : c(...k);\n      }\n      r.on(a, l);\n      const f = o.get(a) || /* @__PURE__ */ new Map();\n      o.set(a, f);\n      const P = f.get(c) || [];\n      return f.set(c, P), P.push([l, i || !1]), _;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    r.emit,\n    function() {\n      const a = r.all.size;\n      r.all.clear(), o.clear(), a && t();\n    }\n  ];\n}\nfunction A(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: e, eventData: t }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet g = !1;\nconst [E, ce] = O(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return g;\n  }\n}), q = (e) => {\n  E(!1, \"Event received:\", e);\n};\nfunction ie(e) {\n  e !== g && (g = e, g ? B(\"*\", q) : _e(\"*\", q));\n}\nconst pe = {\n  clipboard_text_received: u({\n    req_id: w(),\n    data: d(w())\n  }),\n  custom_method_invoked: u({\n    req_id: w(),\n    result: M(X()),\n    error: M(w())\n  }),\n  popup_closed: d(\n    u({ button_id: d(w(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: u({\n    height: x(),\n    width: d(x(), () => window.innerWidth),\n    is_state_stable: S(),\n    is_expanded: S()\n  }),\n  theme_changed: u({\n    theme_params: re()\n  })\n};\nfunction L(e) {\n  if (e.source !== window.parent)\n    return;\n  let t;\n  try {\n    t = v(U(w(), z(), D), e.data);\n  } catch {\n    return;\n  }\n  const { eventType: r, eventData: o } = t, s = pe[r];\n  try {\n    const n = s ? v(s, o) : o;\n    ue(r, n);\n  } catch (n) {\n    ce(\n      !0,\n      [\n        `An error occurred processing the \"${r}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      t,\n      n\n    );\n  }\n}\nconst [\n  B,\n  _e,\n  ue,\n  le\n] = se(\n  () => {\n    const e = window, t = { receiveEvent: A };\n    e.TelegramGameProxy_receiveEvent = A, e.TelegramGameProxy = t, e.Telegram = { WebView: t }, window.addEventListener(\"message\", L);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((e) => {\n      delete window[e];\n    }), window.removeEventListener(\"message\", L);\n  }\n), [\n  we,\n  Le\n] = b(\n  \"MethodUnsupportedError\",\n  (e, t) => [\n    `Method \"${e}\" is unsupported in Mini Apps version ${t}`\n  ]\n), [\n  fe,\n  Te\n] = b(\n  \"MethodParameterUnsupportedError\",\n  (e, t, r) => [\n    `Parameter \"${t}\" of \"${e}\" method is unsupported in Mini Apps version ${r}`\n  ]\n), [\n  me,\n  Ce\n] = ae(\n  \"LaunchParamsRetrieveError\",\n  (e) => ({ errors: e }),\n  (e) => [\n    [\n      \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n      \"📖 Refer to docs for more information:\",\n      \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\",\n      \"\",\n      \"Collected errors:\",\n      ...e.map(([t, r]) => `Source: ${t} / ${r instanceof Error ? r.message : String(r)}`)\n    ].join(`\n`)\n  ]\n), [\n  be,\n  Ie\n] = b(\n  \"InvalidLaunchParamsError\",\n  (e, t) => [\n    `Invalid value for launch params: ${e}`,\n    { cause: t }\n  ]\n), [de, We] = b(\"UnknownEnvError\"), [\n  ge,\n  Re\n] = b(\n  \"InvokeCustomMethodError\",\n  (e) => [`Server returned error: ${e}`]\n), m = G((...e) => window.parent.postMessage(...e)), he = (...e) => m()(...e), K = G(\"https://web.telegram.org\");\nfunction Y(e, t) {\n  E(!1, \"Posting event:\", t ? { eventType: e, eventData: t } : { eventType: e });\n  const r = window, o = JSON.stringify({ eventType: e, eventData: t });\n  if (Q())\n    return he(o, K());\n  if (J(r)) {\n    r.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));\n    return;\n  }\n  if (h(u({ external: u({ notify: R() }) }), r)) {\n    r.external.notify(o);\n    return;\n  }\n  throw new de();\n}\nfunction F(e, t, r) {\n  r || (r = {});\n  const { capture: o } = r, [s, n] = V();\n  return new $((a) => {\n    (Array.isArray(t) ? t : [t]).forEach((c) => {\n      s(\n        B(c, (i) => {\n          (!o || (Array.isArray(t) ? o({\n            event: c,\n            payload: i\n          }) : o(i))) && a(i);\n        })\n      );\n    }), (r.postEvent || Y)(e, r.params);\n  }, r).finally(n);\n}\nconst T = \"launchParams\";\nfunction C(e) {\n  return e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction H() {\n  const e = [];\n  for (const [t, r] of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    [() => C(window.location.href), \"window.location.href\"],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const o = performance.getEntriesByType(\"navigation\")[0];\n      return o && C(o.name);\n    }, \"performance navigation entries\"],\n    [() => ee(T), \"local storage\"]\n  ]) {\n    const o = t();\n    if (!o) {\n      e.push([r, new Error(\"Source is empty\")]);\n      continue;\n    }\n    if (N(o))\n      return j(T, o), o;\n    try {\n      y(o);\n    } catch (s) {\n      e.push([r, s]);\n    }\n  }\n  throw new me(e);\n}\nfunction ve(e) {\n  const t = y(H());\n  return e ? te(t) : t;\n}\nfunction Ue(e, t) {\n  if (!e)\n    try {\n      return ve(), !0;\n    } catch {\n      return !1;\n    }\n  return $.fn(async (r) => {\n    if (J(window))\n      return !0;\n    try {\n      return await F(\"web_app_request_theme\", \"theme_changed\", r), !0;\n    } catch {\n      return !1;\n    }\n  }, t || { timeout: 100 });\n}\nfunction $e({ launchParams: e, onEvent: t, resetPostMessage: r } = {}) {\n  if (e) {\n    const n = typeof e == \"string\" || e instanceof URLSearchParams ? e.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      oe({ ...e, tgWebAppData: void 0 }) + (e.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(e.tgWebAppData.toString())}` : \"\")\n    );\n    if (!N(n))\n      try {\n        y(n);\n      } catch (a) {\n        throw new be(n, a);\n      }\n    j(\"launchParams\", n);\n  }\n  if (Q()) {\n    if (!t)\n      return;\n    const n = U(\n      w(),\n      z(),\n      D\n    );\n    r && m.reset();\n    const a = m();\n    m.set((...c) => {\n      const [i] = c, _ = () => {\n        a(...c);\n      };\n      if (h(n, i)) {\n        const l = v(n, i);\n        t([l.eventType, l.eventData], _);\n      } else\n        _();\n    });\n    return;\n  }\n  const o = window.TelegramWebviewProxy || {}, s = o.postEvent || (() => {\n  });\n  window.TelegramWebviewProxy = {\n    ...o,\n    postEvent(n, a) {\n      const c = () => {\n        s(n, a);\n      };\n      t ? t([n, a ? JSON.parse(a) : void 0], c) : c();\n    }\n  }, E(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction je() {\n  return new URLSearchParams(H()).get(\"tgWebAppData\") || void 0;\n}\nfunction ye(e) {\n  return ({ req_id: t }) => t === e;\n}\nfunction I(e) {\n  return e.split(\".\").map(Number);\n}\nfunction Ee(e, t) {\n  const r = I(e), o = I(t), s = Math.max(r.length, o.length);\n  for (let n = 0; n < s; n += 1) {\n    const a = r[n] || 0, c = o[n] || 0;\n    if (a !== c)\n      return a > c ? 1 : -1;\n  }\n  return 0;\n}\nfunction p(e, t) {\n  return Ee(e, t) <= 0;\n}\nfunction W(e, t, r) {\n  if (typeof r == \"string\") {\n    if (e === \"web_app_open_link\") {\n      if (t === \"try_instant_view\")\n        return p(\"6.4\", r);\n      if (t === \"try_browser\")\n        return p(\"7.6\", r);\n    }\n    if (e === \"web_app_set_header_color\" && t === \"color\")\n      return p(\"6.9\", r);\n    if (e === \"web_app_close\" && t === \"return_back\")\n      return p(\"7.6\", r);\n    if (e === \"web_app_setup_main_button\" && t === \"has_shine_effect\")\n      return p(\"7.10\", r);\n  }\n  switch (e) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return p(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return p(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return p(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return p(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return p(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return p(\"6.10\", t);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return p(\"7.2\", t);\n    case \"web_app_setup_swipe_behavior\":\n      return p(\"7.7\", t);\n    case \"web_app_share_to_story\":\n      return p(\"7.8\", t);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return p(\"7.10\", t);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return p(\"8.0\", t);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(e);\n  }\n}\nfunction ze(e, t) {\n  t || (t = \"strict\");\n  const r = typeof t == \"function\" ? t : (o) => {\n    const { method: s, version: n } = o, a = \"param\" in o ? new fe(s, o.param, n) : new we(s, n);\n    if (t === \"strict\")\n      throw a;\n    return console.warn(a.message);\n  };\n  return (o, s) => W(o, e) ? o === \"web_app_set_header_color\" && h(u({ color: Z() }), s) && !W(o, \"color\", e) ? r({ version: e, method: o, param: \"color\" }) : Y(o, s) : r({ version: e, method: o });\n}\nfunction De(e, t, r, o) {\n  return F(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...o || {},\n    params: { method: e, params: t, req_id: r },\n    capture: ye(r)\n  }).then(({ result: s, error: n }) => {\n    if (n)\n      throw new ge(n);\n    return s;\n  });\n}\nfunction Ne() {\n  le(), ie(!1), [m, K].forEach((e) => {\n    e.unsubAll(), e.reset();\n  });\n}\nexport {\n  Qe as AbortablePromise,\n  Be as CancelledError,\n  be as InvalidLaunchParamsError,\n  ge as InvokeCustomMethodError,\n  me as LaunchParamsRetrieveError,\n  Ke as ManualPromise,\n  fe as MethodParameterUnsupportedError,\n  we as MethodUnsupportedError,\n  Ye as TimeoutError,\n  de as UnknownEnvError,\n  ye as captureSameReq,\n  Ee as compareVersions,\n  ze as createPostEvent,\n  A as emitEvent,\n  J as hasWebviewProxy,\n  De as invokeCustomMethod,\n  Fe as isCancelledError,\n  Q as isIframe,\n  Ie as isInvalidLaunchParamsError,\n  Re as isInvokeCustomMethodError,\n  Ce as isLaunchParamsRetrieveError,\n  Te as isMethodMethodParameterUnsupportedError,\n  Le as isMethodUnsupportedError,\n  Ue as isTMA,\n  He as isTimeoutError,\n  We as isUnknownEnvError,\n  $e as mockTelegramEnv,\n  _e as off,\n  le as offAll,\n  B as on,\n  Y as postEvent,\n  he as postMessage,\n  m as postMessageImplementation,\n  F as request,\n  Ne as resetPackageState,\n  ve as retrieveLaunchParams,\n  je as retrieveRawInitData,\n  H as retrieveRawLaunchParams,\n  ie as setDebug,\n  W as supports,\n  K as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_$launchParams, $launchParams] = createSignalsTuple<PackageLaunchParams>({\n  tgWebAppPlatform: 'unknown',\n  tgWebAppVersion: '0.0',\n});\n\nexport const version = createComputed(() => $launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _$launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _$launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);\n\nexport const [\n  UnknownThemeParamsKeyError,\n  isUnknownThemeParamsKeyError,\n] = errorClass<[key: string]>('UnknownThemeParamsKeyError', key => {\n  return [`Unknown theme params key passed: ${key}`];\n});","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport { array, parse, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      const response = {\n        // Fulfill the response with probably missing keys.\n        ...keys.reduce<Record<string, string>>((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {}),\n        ...parse(record(string(), string()), data),\n      };\n\n      return typeof keyOrKeys === 'string' ? response[keyOrKeys] : response;\n    })\n    : AbortablePromise.resolve(Array.isArray(keyOrKeys) ? {} : '');\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport { batch } from '@telegram-apps/signals';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  (_options?: RequestOptionsNoCapture): AbortablePromise<ThemeParams> => {\n    return AbortablePromise.resolve(\n      (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {},\n    );\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapBasic('mountSync', () => {\n  if (!_isMounted()) {\n    const tp = (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {};\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    batch(() => {\n      _state.set(tp);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport type { RGB } from '@telegram-apps/types';\nimport { isRGB } from '@telegram-apps/transformers';\n\nimport { state as themeParamsState } from '@/scopes/components/theme-params/signals.js';\nimport { createComputed } from '@/signals-registry.js';\n\nimport type { AnyColor } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nexport function rgbComputedBasedOn(signal: Computed<AnyColor>): Computed<RGB | undefined> {\n  return createComputed<RGB | undefined>(() => rgbBasedOn(signal()));\n}\n\nexport function rgbBasedOn(color: AnyColor): RGB | undefined {\n  return isRGB(color) ? color : themeParamsState()[color];\n}","import { isRGB } from '@telegram-apps/transformers';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  state as themeParamsState,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport { rgbComputedBasedOn } from './utils.js';\n\nimport type { AnyColor, State } from './types.js';\n\n/**\n * The Mini App background color.\n *\n * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n *\n * Note that using a theme parameters key, background color becomes bound to the current\n * theme parameters, making it automatically being updated whenever theme parameters change.\n * In order to remove this bind, use an explicit RGB color.\n */\nexport const [_backgroundColor, backgroundColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbComputedBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] = createSignalsTuple<AnyColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    // Falling back to secondary_bg_color following the logic from the Telegram SDK.\n    : themeParamsState()[color] || themeSecondaryBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbComputedBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { type Computed, type SubscribeListenerFn, batch } from '@telegram-apps/signals';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\n\nimport { version, postEvent } from '@/globals.js';\nimport {\n  mount as mountThemeParams,\n  mountSync as mountThemeParamsSync,\n} from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { AnyColor, GetCssVarNameFn, State } from './types.js';\nimport { rgbBasedOn } from './utils.js';\nimport { themeParamsState } from '@/scopes/components/theme-params/exports.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst onThemeParamsChanged: SubscribeListenerFn<ThemeParams> = themeParams => {\n  ([\n    [_headerColor, SET_HEADER_COLOR_METHOD],\n    [_backgroundColor, SET_BG_COLOR_METHOD],\n    [_bottomBarColor, SET_BOTTOM_BAR_COLOR_METHOD],\n  ] as const).forEach(([signal, method]) => {\n    const color = signal();\n    if (!isRGB(color) && (\n      // Header color setter uses additional checks. We don't apply changes if the current\n      // value is a known color key because it updates automatically by itself.\n      method !== SET_HEADER_COLOR_METHOD\n      || (color !== 'bg_color' && color !== 'secondary_bg_color')\n    )) {\n      const rgb = themeParams[color];\n      rgb && postEvent(method, { color: rgb });\n    }\n  });\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapSupported('mountSync', () => {\n  if (!_isMounted()) {\n    mountThemeParamsSync();\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n\n    batch(() => {\n      _isActive.set(s ? s.isActive : true);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: AnyColor): void => {\n    if (color === _backgroundColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BG_COLOR_METHOD, { color: rgb });\n    _backgroundColor.set(color);\n    saveState();\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('#ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: AnyColor) => {\n    if (color === _bottomBarColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color: rgb });\n    _bottomBarColor.set(color);\n    saveState();\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: AnyColor): void => {\n    if (color === _headerColor()) {\n      return;\n    }\n    if (color === 'bg_color' || color === 'secondary_bg_color') {\n      postEvent(SET_HEADER_COLOR_METHOD, { color_key: color });\n    } else {\n      const rgb = rgbBasedOn(color);\n      if (!rgb) {\n        throw new UnknownThemeParamsKeyError(color);\n      }\n      postEvent(SET_HEADER_COLOR_METHOD, { color: rgb });\n    }\n    _headerColor.set(color);\n    saveState();\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  themeParamsState.unsub(onThemeParamsChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { ShowOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [fn, tPromise, tShowError] = defineNonConcurrentFn(\n  (options: ShowOptions): AbortablePromise<string | null> => {\n    return request(OPEN_METHOD, 'popup_closed', {\n      ...options,\n      params: prepareParams(options),\n    }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n  },\n  'A popup is already opened',\n);\n\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `show` instead.\n */\nexport const open = wrapSupported('open', fn);\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showPromise` instead.\n */\nconst openPromise = tPromise[1];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `isShown` instead.\n */\nconst isOpened = tPromise[2];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showError` instead.\n */\nconst openError = tShowError[1];\n\nexport { openPromise, isOpened, openError };\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const show = wrapSupported('show', fn);\nexport const [, showPromise, isShown] = tPromise;\nexport const [, showError] = tShowError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = $launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\nconst fnOptions = {\n  isSupported: 'web_app_request_phone',\n} as const;\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContactCompleteData> {\n  const raw = parse(string(), await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  }));\n  return {\n    raw,\n    parsed: parse(\n      pipe(\n        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n        union([string(), instance(URLSearchParams)]),\n        transformQueryUsing(\n          looseObject({\n            contact: pipe(\n              string(),\n              jsonParse(),\n              looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              }),\n            ),\n            auth_date: pipe(\n              string(),\n              transform(input => new Date(Number(input) * 1000)),\n              date(),\n            ),\n            hash: string(),\n          }),\n        ),\n      ),\n      raw,\n    ),\n  };\n}\n\nconst [fn, tPromise, tError] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContactCompleteData> => {\n    return new AbortablePromise<RequestedContactCompleteData>(\n      async (res, _, context) => {\n        // First of all, let's try to get the requested contact. Probably, we already requested it\n        // before.\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Then, request access to the user's phone.\n        const status = await requestPhoneAccess(context);\n        if (status !== 'sent') {\n          throw new AccessDeniedError('User denied access');\n        }\n\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isAborted()) {\n          try {\n            return res(await getRequestedContact(context));\n          } catch (e) {\n            if (e instanceof ValiError) {\n              throw e;\n            }\n          }\n\n          // Sleep for some time.\n          await sleep(sleepTime);\n\n          // Increase the sleep time not to kill the backend service.\n          sleepTime += 50;\n        }\n      },\n      options,\n    );\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n *\n * This function returns an object, containing both raw and parsed representations of the response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContactComplete.isAvailable()) {\n *   const completeData = await requestContactComplete();\n * }\n */\nexport const requestContactComplete = wrapSafe('requestContactComplete', fn, fnOptions);\n\n/**\n * Works the same way as the `requestContactComplete` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactComplete\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe(\n  'requestContact',\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return requestContactComplete(options).then(r => r.parsed);\n  },\n  fnOptions,\n);\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_data_send';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent(METHOD_NAME, { data });\n  },\n  { isSupported: METHOD_NAME },\n);\n","import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { $launchParams, postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n  {\n    isSupported() {\n      return $launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    }\n  }\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","type","_b","_addIssue","context","label","dataset","other","expected","received","issue","isSchema","message","_getStandardProps","value2","_isValidObjectKey","object2","key","_joinExpects","values2","separator","list","ValiError","issues","integer","transform","operation","getFallback","schema","getDefault","is","any","array","item","itemDataset","pathItem","boolean","date","function_","instance","class_","looseObject","entries","valueSchema","valueDataset","nullish","wrapped","default_","number","optional","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","options","option","validDataset","typedDatasets","untypedDatasets","optionDataset","unknown","parse","pipe","pipe2","V","Y","r","e","y","$","k","q","z","P","c","s","G","M","H","N","B","C","J","x","m","a","i","v","d","j","n","h","p","F","g","l","w","D","f","A","E","L","S","T","I","R","o","t","u","Z","ee","ne","re","W","te","se","U","ie","_","O","ue","ae","oe","ce","K","Q","he","le","pe","fe","ye","me","ge","be","de","X","ke","_e","Se","ve","Ee","De","b","we","Le","Te","Ce","Ie","We","Re","Ue","$e","je","ze","createSignal","initialValue","signal","createComputed","fn","computed","createSignalsTuple","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_$launchParams","$launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","ShareMessageError","isShareMessageError","UnknownThemeParamsKeyError","isUnknownThemeParamsKeyError","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","tuple","supportError","getError","isSupportedItems","errors","supportsOptionError","args","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","on","offClick","off","show","unmount","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","defineMountFn","onMounted","rest","data","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","mountPromise","mountError","authFn","tAuthPromise","tAuthError","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","createWrapMounted","createWrapBasic","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","wrapBasic","disableConfirmation","setClosingConfirmation","enableConfirmation","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","response","acc","getItem","getKeys","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","CHECK_LOCATION_METHOD","OPEN_SETTINGS_METHOD","isAccessGranted","isAccessRequested","reqLocationFn","tReqLocationPromise","tReqLocationError","requestLocation","requestLocationPromise","isRequestingLocation","requestLocationError","removeUndefined","result","isColorDark","color","rgb","toRGB","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","_options","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","mountSync","tp","rgbComputedBasedOn","rgbBasedOn","isRGB","themeParamsState","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeSecondaryBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","onThemeParamsChanged","themeParams","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","mountThemeParamsSync","ready","prepareParams","title","buttons","id","OPEN_METHOD","tPromise","tShowError","buttonId","showPromise","isShown","showError","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","fnOptions","getRequestedContact","transformQueryUsing","jsonParse","res","sleepTime","requestContactComplete","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","fallback","textArea","copyTextToClipboard","clipboard","downloadFile","fileName","getCurrentTime","readTextFromClipboard","reqId","captureSameReq","sendData","size","shareMessage","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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","x_google_ignoreList":[0,1,4,5]}