import { is as h, looseObject as u, function as R, string as w, nullish as d, optional as M, unknown as X, number as x, boolean as S, parse as v, pipe as U, any as Z } from "valibot";
import { AbortablePromise as $ } from "better-promises";
import { AbortablePromise as Qe, CancelledError as Be, ManualPromise as Ke, TimeoutError as Ye, isCancelledError as Fe, isTimeoutError as He } from "better-promises";
import { createLogger as O, createCbCollector as V, getStorageValue as ee, setStorageValue as j, deepSnakeToCamelObjKeys as te } from "@telegram-apps/toolkit";
import { themeParams as re, jsonParse as z, MiniAppsMessageSchema as D, isLaunchParamsQuery as N, parseLaunchParamsQuery as y, serializeLaunchParamsQuery as oe } from "@telegram-apps/transformers";
import ne from "mitt";
import { errorClass as b, errorClassWithData as ae } from "error-kid";
import { signal as G } from "@telegram-apps/signals";
function J(e) {
  return h(
    u({ TelegramWebviewProxy: u({ postEvent: R() }) }),
    e
  );
}
function Q() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
function se(e, t) {
  const r = ne(), o = /* @__PURE__ */ new Map(), s = (n, a, c) => {
    c || (c = !1);
    const i = o.get(n) || /* @__PURE__ */ new Map();
    o.set(n, i);
    const _ = i.get(a) || [];
    i.set(a, _);
    const l = _.findIndex((f) => f[1] === c);
    l >= 0 && (r.off(n, _[l][0]), _.splice(l, 1), !_.length && i.delete(a), i.size || (o.delete(n), !o.size && t()));
  };
  return [
    function(a, c, i) {
      !o.size && e();
      function _() {
        s(a, c, i);
      }
      function l(...k) {
        i && _(), a === "*" ? c(k) : c(...k);
      }
      r.on(a, l);
      const f = o.get(a) || /* @__PURE__ */ new Map();
      o.set(a, f);
      const P = f.get(c) || [];
      return f.set(c, P), P.push([l, i || !1]), _;
    },
    s,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    r.emit,
    function() {
      const a = r.all.size;
      r.all.clear(), o.clear(), a && t();
    }
  ];
}
function A(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
let g = !1;
const [E, ce] = O("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog() {
    return g;
  }
}), q = (e) => {
  E(!1, "Event received:", e);
};
function ie(e) {
  e !== g && (g = e, g ? B("*", q) : _e("*", q));
}
const pe = {
  clipboard_text_received: u({
    req_id: w(),
    data: d(w())
  }),
  custom_method_invoked: u({
    req_id: w(),
    result: M(X()),
    error: M(w())
  }),
  popup_closed: d(
    u({ button_id: d(w(), () => {
    }) }),
    {}
  ),
  viewport_changed: u({
    height: x(),
    width: d(x(), () => window.innerWidth),
    is_state_stable: S(),
    is_expanded: S()
  }),
  theme_changed: u({
    theme_params: re()
  })
};
function L(e) {
  if (e.source !== window.parent)
    return;
  let t;
  try {
    t = v(U(w(), z(), D), e.data);
  } catch {
    return;
  }
  const { eventType: r, eventData: o } = t, s = pe[r];
  try {
    const n = s ? v(s, o) : o;
    ue(r, n);
  } catch (n) {
    ce(
      !0,
      [
        `An error occurred processing the "${r}" event from the Telegram application.`,
        "Please, file an issue here:",
        "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
      ].join(`
`),
      t,
      n
    );
  }
}
const [
  B,
  _e,
  ue,
  le
] = se(
  () => {
    const e = window, t = { receiveEvent: A };
    e.TelegramGameProxy_receiveEvent = A, e.TelegramGameProxy = t, e.Telegram = { WebView: t }, window.addEventListener("message", L);
  },
  () => {
    ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
      delete window[e];
    }), window.removeEventListener("message", L);
  }
), [
  we,
  Le
] = b(
  "MethodUnsupportedError",
  (e, t) => [
    `Method "${e}" is unsupported in Mini Apps version ${t}`
  ]
), [
  fe,
  Te
] = b(
  "MethodParameterUnsupportedError",
  (e, t, r) => [
    `Parameter "${t}" of "${e}" method is unsupported in Mini Apps version ${r}`
  ]
), [
  me,
  Ce
] = ae(
  "LaunchParamsRetrieveError",
  (e) => ({ errors: e }),
  (e) => [
    [
      "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
      "ðŸ“– Refer to docs for more information:",
      "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment",
      "",
      "Collected errors:",
      ...e.map(([t, r]) => `Source: ${t} / ${r instanceof Error ? r.message : String(r)}`)
    ].join(`
`)
  ]
), [
  be,
  Ie
] = b(
  "InvalidLaunchParamsError",
  (e, t) => [
    `Invalid value for launch params: ${e}`,
    { cause: t }
  ]
), [de, We] = b("UnknownEnvError"), [
  ge,
  Re
] = b(
  "InvokeCustomMethodError",
  (e) => [`Server returned error: ${e}`]
), m = G((...e) => window.parent.postMessage(...e)), he = (...e) => m()(...e), K = G("https://web.telegram.org");
function Y(e, t) {
  E(!1, "Posting event:", t ? { eventType: e, eventData: t } : { eventType: e });
  const r = window, o = JSON.stringify({ eventType: e, eventData: t });
  if (Q())
    return he(o, K());
  if (J(r)) {
    r.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
    return;
  }
  if (h(u({ external: u({ notify: R() }) }), r)) {
    r.external.notify(o);
    return;
  }
  throw new de();
}
function F(e, t, r) {
  r || (r = {});
  const { capture: o } = r, [s, n] = V();
  return new $((a) => {
    (Array.isArray(t) ? t : [t]).forEach((c) => {
      s(
        B(c, (i) => {
          (!o || (Array.isArray(t) ? o({
            event: c,
            payload: i
          }) : o(i))) && a(i);
        })
      );
    }), (r.postEvent || Y)(e, r.params);
  }, r).finally(n);
}
const T = "launchParams";
function C(e) {
  return e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&");
}
function H() {
  const e = [];
  for (const [t, r] of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    [() => C(window.location.href), "window.location.href"],
    // Then, try using the lower level API - window.performance.
    [() => {
      const o = performance.getEntriesByType("navigation")[0];
      return o && C(o.name);
    }, "performance navigation entries"],
    [() => ee(T), "local storage"]
  ]) {
    const o = t();
    if (!o) {
      e.push([r, new Error("Source is empty")]);
      continue;
    }
    if (N(o))
      return j(T, o), o;
    try {
      y(o);
    } catch (s) {
      e.push([r, s]);
    }
  }
  throw new me(e);
}
function ve(e) {
  const t = y(H());
  return e ? te(t) : t;
}
function Ue(e, t) {
  if (!e)
    try {
      return ve(), !0;
    } catch {
      return !1;
    }
  return $.fn(async (r) => {
    if (J(window))
      return !0;
    try {
      return await F("web_app_request_theme", "theme_changed", r), !0;
    } catch {
      return !1;
    }
  }, t || { timeout: 100 });
}
function $e({ launchParams: e, onEvent: t, resetPostMessage: r } = {}) {
  if (e) {
    const n = typeof e == "string" || e instanceof URLSearchParams ? e.toString() : (
      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid
      // value. We are doing it because we are working with tgWebAppData presented as a
      // string, not an object as serializeLaunchParamsQuery requires.
      oe({ ...e, tgWebAppData: void 0 }) + (e.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(e.tgWebAppData.toString())}` : "")
    );
    if (!N(n))
      try {
        y(n);
      } catch (a) {
        throw new be(n, a);
      }
    j("launchParams", n);
  }
  if (Q()) {
    if (!t)
      return;
    const n = U(
      w(),
      z(),
      D
    );
    r && m.reset();
    const a = m();
    m.set((...c) => {
      const [i] = c, _ = () => {
        a(...c);
      };
      if (h(n, i)) {
        const l = v(n, i);
        t([l.eventType, l.eventData], _);
      } else
        _();
    });
    return;
  }
  const o = window.TelegramWebviewProxy || {}, s = o.postEvent || (() => {
  });
  window.TelegramWebviewProxy = {
    ...o,
    postEvent(n, a) {
      const c = () => {
        s(n, a);
      };
      t ? t([n, a ? JSON.parse(a) : void 0], c) : c();
    }
  }, E(!1, "Environment was mocked by the mockTelegramEnv function");
}
function je() {
  return new URLSearchParams(H()).get("tgWebAppData") || void 0;
}
function ye(e) {
  return ({ req_id: t }) => t === e;
}
function I(e) {
  return e.split(".").map(Number);
}
function Ee(e, t) {
  const r = I(e), o = I(t), s = Math.max(r.length, o.length);
  for (let n = 0; n < s; n += 1) {
    const a = r[n] || 0, c = o[n] || 0;
    if (a !== c)
      return a > c ? 1 : -1;
  }
  return 0;
}
function p(e, t) {
  return Ee(e, t) <= 0;
}
function W(e, t, r) {
  if (typeof r == "string") {
    if (e === "web_app_open_link") {
      if (t === "try_instant_view")
        return p("6.4", r);
      if (t === "try_browser")
        return p("7.6", r);
    }
    if (e === "web_app_set_header_color" && t === "color")
      return p("6.9", r);
    if (e === "web_app_close" && t === "return_back")
      return p("7.6", r);
    if (e === "web_app_setup_main_button" && t === "has_shine_effect")
      return p("7.10", r);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return p("6.1", t);
    case "web_app_open_popup":
      return p("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return p("6.4", t);
    case "web_app_switch_inline_query":
      return p("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return p("6.9", t);
    case "web_app_setup_settings_button":
      return p("6.10", t);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return p("7.2", t);
    case "web_app_setup_swipe_behavior":
      return p("7.7", t);
    case "web_app_share_to_story":
      return p("7.8", t);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return p("7.10", t);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_add_to_home_screen":
    case "web_app_check_home_screen":
    case "web_app_request_emoji_status_access":
    case "web_app_check_location":
    case "web_app_open_location_settings":
    case "web_app_request_file_download":
    case "web_app_request_location":
    case "web_app_send_prepared_message":
    case "web_app_start_accelerometer":
    case "web_app_start_device_orientation":
    case "web_app_start_gyroscope":
    case "web_app_stop_accelerometer":
    case "web_app_stop_device_orientation":
    case "web_app_stop_gyroscope":
    case "web_app_toggle_orientation_lock":
      return p("8.0", t);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function ze(e, t) {
  t || (t = "strict");
  const r = typeof t == "function" ? t : (o) => {
    const { method: s, version: n } = o, a = "param" in o ? new fe(s, o.param, n) : new we(s, n);
    if (t === "strict")
      throw a;
    return console.warn(a.message);
  };
  return (o, s) => W(o, e) ? o === "web_app_set_header_color" && h(u({ color: Z() }), s) && !W(o, "color", e) ? r({ version: e, method: o, param: "color" }) : Y(o, s) : r({ version: e, method: o });
}
function De(e, t, r, o) {
  return F("web_app_invoke_custom_method", "custom_method_invoked", {
    ...o || {},
    params: { method: e, params: t, req_id: r },
    capture: ye(r)
  }).then(({ result: s, error: n }) => {
    if (n)
      throw new ge(n);
    return s;
  });
}
function Ne() {
  le(), ie(!1), [m, K].forEach((e) => {
    e.unsubAll(), e.reset();
  });
}
export {
  Qe as AbortablePromise,
  Be as CancelledError,
  be as InvalidLaunchParamsError,
  ge as InvokeCustomMethodError,
  me as LaunchParamsRetrieveError,
  Ke as ManualPromise,
  fe as MethodParameterUnsupportedError,
  we as MethodUnsupportedError,
  Ye as TimeoutError,
  de as UnknownEnvError,
  ye as captureSameReq,
  Ee as compareVersions,
  ze as createPostEvent,
  A as emitEvent,
  J as hasWebviewProxy,
  De as invokeCustomMethod,
  Fe as isCancelledError,
  Q as isIframe,
  Ie as isInvalidLaunchParamsError,
  Re as isInvokeCustomMethodError,
  Ce as isLaunchParamsRetrieveError,
  Te as isMethodMethodParameterUnsupportedError,
  Le as isMethodUnsupportedError,
  Ue as isTMA,
  He as isTimeoutError,
  We as isUnknownEnvError,
  $e as mockTelegramEnv,
  _e as off,
  le as offAll,
  B as on,
  Y as postEvent,
  he as postMessage,
  m as postMessageImplementation,
  F as request,
  Ne as resetPackageState,
  ve as retrieveLaunchParams,
  je as retrieveRawInitData,
  H as retrieveRawLaunchParams,
  ie as setDebug,
  W as supports,
  K as targetOrigin
};
//# sourceMappingURL=index.js.map
